# .github/workflows/cd.yml - Mobile Unified Release System
#
# OVERVIEW:
# =========
# This workflow implements a unified release system that coordinates iOS builds (via Codemagic)
# and Android builds (via GitHub Actions) using a branch-based approach.
#
# TRIGGER:
# =======
# - push to branches matching pattern: 'release/*'
# - Validates semantic version format (e.g., 2.1.0, 2.1.0-beta2, 2.1.0-rc1)
# - Rejects invalid branch names (test, fix, hotfix, experimental, wip, temp)
#
# WORKFLOW FLOW:
# ===============
# 1. prepare-release: Extract version, update pubspec.yaml, create git tag, merge to main
# 2. build-ios: Trigger Codemagic build, wait completion, download artifacts
# 3. build-android: Build APK/AAB in parallel
# 4. create-unified-release: Create GitHub release, update AltStore PAL source
# 5. handle-failures: Notify on build failures
#
# SECURITY:
# ==========
# - Semantic version regex validation prevents unauthorized releases
# - All secrets properly stored in GitHub Actions secrets
# - No hardcoded credentials in any scripts or configurations
# - Fail-fast on any validation errors
#
# ARCHITECTURE:
# ============
# - GitHub Actions: Central coordinator and version management
# - Codemagic: Build-only iOS execution (no version management conflicts)
# - AltStore PAL: Automatic source updates for iOS distribution
# - Firebase: App Distribution integration for testing
#
name: Mobile Unified Release

permissions:
  contents: write
  pull-requests: write

on:
  push:
    branches:
      - 'release/*'

env:
  # Flutter configuration
  FLUTTER_VERSION: ${{ vars.FLUTTER_VERSION || '3.38.2' }}
  JAVA_VERSION: ${{ vars.JAVA_VERSION || '17' }}

jobs:
  # Job 1: Prepare release environment
  prepare-release:
    name: Prepare Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      flavor: ${{ steps.version.outputs.flavor }}
      tag_name: ${{ steps.version.outputs.tag_name }}
      is_staging: ${{ steps.version.outputs.is_staging }}
      base_version: ${{ steps.version.outputs.base_version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Load CI/CD versions
        id: load-versions
        run: |
          if [[ -f ".github/ci-versions.env" ]]; then
            while IFS='=' read -r key value; do
              # Skip empty lines and comments
              if [[ -n "$key" && ! "$key" =~ ^[[:space:]]*# ]]; then
                echo "$key=$value" >> $GITHUB_OUTPUT
              fi
            done < .github/ci-versions.env
          fi

      - name: Validate version format
        id: validate-version
        run: |
          BRANCH_NAME="${GITHUB_REF_NAME}"
          echo "Processing release branch: $BRANCH_NAME"

          # Extract version from branch name (remove 'release/' prefix)
          VERSION="${BRANCH_NAME#release/}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

          # Validate semantic version format
          # Patterns:
          # - 2.1.0 (production)
          # - 2.1.0-alpha1, 2.1.0-beta2, 2.1.0-rc1 (staging)
          if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-((alpha|beta|rc)[0-9]*))?$ ]]; then
            echo "‚ùå Invalid version format: $VERSION"
            echo ""
            echo "Expected formats:"
            echo "  - 2.1.0 (production)"
            echo "  - 2.1.0-alpha1 (staging)"
            echo "  - 2.1.0-beta2 (staging)"
            echo "  - 2.1.0-rc1 (staging)"
            echo ""
            echo "Rejected: test, fix, hotfix, bugfix, experimental, wip, temp, etc."
            echo ""
            echo "Please use semantic versioning format in release/ branches."
            exit 1
          fi

          # Extract base version (remove pre-release)
          BASE_VERSION=$(echo "$VERSION" | sed -E 's/(-alpha|-beta|-rc).*//')
          echo "base_version=$BASE_VERSION" >> $GITHUB_OUTPUT

          # Create tag name for later use
          TAG_NAME="v$VERSION"
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

          # Determine flavor from version pattern
          if [[ "$VERSION" =~ (alpha|beta|rc) ]]; then
            FLAVOR="staging"
            IS_STAGING="true"
          else
            FLAVOR="production"
            IS_STAGING="false"
          fi

          echo "flavor=$FLAVOR" >> $GITHUB_OUTPUT
          echo "is_staging=$IS_STAGING" >> $GITHUB_OUTPUT

          echo "‚úÖ Version format validated: $VERSION"
          echo "üìã Release Info:"
          echo "   Branch: $BRANCH_NAME"
          echo "   Version: $VERSION"
          echo "   Tag: $TAG_NAME"
          echo "   Base Version: $BASE_VERSION"
          echo "   Flavor: $FLAVOR"
          echo "   Staging: $IS_STAGING"

      - name: Extract version and flavor from branch
        id: version
        run: |
          # This step now just passes through the validated values
          echo "version=${{ steps.validate-version.outputs.version }}" >> $GITHUB_OUTPUT
          echo "base_version=${{ steps.validate-version.outputs.base_version }}" >> $GITHUB_OUTPUT
          echo "tag_name=${{ steps.validate-version.outputs.tag_name }}" >> $GITHUB_OUTPUT
          echo "flavor=${{ steps.validate-version.outputs.flavor }}" >> $GITHUB_OUTPUT
          echo "is_staging=${{ steps.validate-version.outputs.is_staging }}" >> $GITHUB_OUTPUT

      - name: Check if release already exists
        id: check-release
        run: |
          TAG_NAME="${{ steps.version.outputs.tag_name }}"
          VERSION="${{ steps.version.outputs.version }}"
          BRANCH_NAME="${GITHUB_REF_NAME}"

          echo "üîç Checking if release $TAG_NAME already exists..."

          # Check if tag already exists
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "‚ùå Release $TAG_NAME already exists!"
            echo "üö´ This version has already been released."
            echo ""
            echo "üìã To rebuild this release:"
            echo "   git tag -d $TAG_NAME"
            echo "   git push origin --delete $TAG_NAME"
            echo "   Then re-run the workflow"
            echo ""
            echo "üéØ Skipping build to avoid duplicate release"
            exit 1
          fi

      - name: Update pubspec.yaml
        run: |
          # Use run number as build number
          BUILD_NUMBER="${{ github.run_number }}"
          BASE_VERSION="${{ steps.version.outputs.base_version }}"

          sed -i "s/^version: .*/version: $BASE_VERSION+$BUILD_NUMBER/" pubspec.yaml

          echo "‚úÖ Updated pubspec.yaml:"
          grep "^version:" pubspec.yaml

      - name: Commit version update
        run: |
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Add and commit version update
          git add pubspec.yaml
          git commit -m "[skip ci] chore: update version to ${{ steps.version.outputs.base_version }}+${{ github.run_number }}"

          # Push commit to release branch (force to avoid conflicts with automation)
          git push origin release/${{ steps.version.outputs.version }} --force

          echo "‚úÖ Committed version update to release/${{ steps.version.outputs.version }}"

      - name: Merge to main and create tag
        run: |
          set -e

          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          TARGET_BRANCH="main"
          RELEASE_BRANCH="release/${{ steps.version.outputs.version }}"
          TAG_NAME="${{ steps.version.outputs.tag_name }}"

          echo "üîÑ Fetching target branch..."
          git fetch origin $TARGET_BRANCH

          echo "üìã Checking out '$TARGET_BRANCH'..."
          git checkout $TARGET_BRANCH

          echo "üîÄ Merging '$RELEASE_BRANCH' into '$TARGET_BRANCH'..."
          git merge origin/$RELEASE_BRANCH --no-ff -m "[skip ci] chore(release): Release ${{ steps.version.outputs.version }}"

          echo "üì§ Pushing merge to '$TARGET_BRANCH'..."
          git push origin $TARGET_BRANCH

          echo "üè∑Ô∏è Creating tag '$TAG_NAME' on '$TARGET_BRANCH'..."
          git tag -a "$TAG_NAME" -m "Release ${{ steps.version.outputs.version }}"
          git push origin "$TAG_NAME"

          echo "üßπ Cleaning up release branch '$RELEASE_BRANCH'..."
          git push origin --delete "$RELEASE_BRANCH"

          echo "‚úÖ Successfully merged $RELEASE_BRANCH to $TARGET_BRANCH"
          echo "‚úÖ Created and pushed tag: $TAG_NAME"
          echo "‚úÖ Deleted release branch: $RELEASE_BRANCH"

  # Job 2: Build iOS (trigger Codemagic)
  build-ios:
    name: Build iOS
    runs-on: ubuntu-latest
    needs: prepare-release
    outputs:
      final_build_info: ${{ steps.wait-ios.outputs.build_info }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Trigger Codemagic iOS build
        id: trigger-ios
        env:
          CODEMAGIC_API_TOKEN: ${{ secrets.CODEMAGIC_API_TOKEN }}
        run: |
          # Map flavor to workflow ID
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          if [[ "$FLAVOR" == "staging" ]]; then
            WORKFLOW_ID="ios-staging"
          elif [[ "$FLAVOR" == "production" ]]; then
            WORKFLOW_ID="ios-production"
          else
            echo "‚ùå Unknown flavor: $FLAVOR"
            exit 1
          fi

          ./scripts/trigger-codemagic-api.sh \
            "${{ vars.CODEMAGIC_APP_ID }}" \
            "$WORKFLOW_ID" \
            "main" \
            "${{ needs.prepare-release.outputs.tag_name }}"

      - name: Wait for iOS build completion
        id: wait-ios
        env:
          CODEMAGIC_API_TOKEN: ${{ secrets.CODEMAGIC_API_TOKEN }}
        run: |
          ./scripts/wait-codemagic-build.sh \
            "${{ steps.trigger-ios.outputs.BUILD_ID }}" \
            "1800" "30"  # 30 minutes max, 30 second polling

      - name: Validate build info availability
        run: |
          echo "üîç Checking build info availability..."

          # Verify build_info is available and valid
          BUILD_INFO="${{ steps.wait-ios.outputs.build_info }}"
          if [[ -z "$BUILD_INFO" ]]; then
            echo "‚ùå Build info not available - build polling may have failed"
            echo "üí° This usually means the wait-codemagic-build.sh script did not complete properly"
            echo "üîó Check the previous step logs for build polling errors"
            exit 1
          fi

          # Validate build info JSON format
          if ! echo "$BUILD_INFO" | jq -e '.build.artefacts' >/dev/null 2>&1; then
            echo "‚ùå Invalid build info JSON format - build polling may have failed"
            echo "üì° Build info content:"
            echo "$BUILD_INFO" | head -c 500
            echo ""
            echo "üí° The build info should be valid JSON with 'build.artefacts' array"
            exit 1
          fi

          echo "‚úÖ Build info validated successfully"
          echo "üì° Build status: $(echo "$BUILD_INFO" | jq -r '.build.status')"
          echo "üì¶ Artifact count: $(echo "$BUILD_INFO" | jq -r '.build.artefacts | length')"

  # Job 3: Build Android (parallel)
  build-android:
    name: Build Android
    runs-on: ubuntu-latest
    needs: prepare-release

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Load CI/CD versions
        id: load-versions
        run: |
          if [[ -f ".github/ci-versions.env" ]]; then
            while IFS='=' read -r key value; do
              # Skip empty lines and comments
              if [[ -n "$key" && ! "$key" =~ ^[[:space:]]*# ]]; then
                echo "$key=$value" >> $GITHUB_OUTPUT
              fi
            done < .github/ci-versions.env
          fi

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ steps.load-versions.outputs.FLUTTER_VERSION }}
          channel: ${{ steps.load-versions.outputs.FLUTTER_CHANNEL }}
          cache: true

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ steps.load-versions.outputs.JAVA_VERSION }}

      - name: Cache Flutter dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.pub-cache
            .dart_tool
          key: v1-${{ runner.os }}-flutter-${{ steps.load-versions.outputs.FLUTTER_VERSION }}-${{ hashFiles('**/pubspec.lock') }}
          restore-keys: |
            v1-${{ runner.os }}-flutter-${{ steps.load-versions.outputs.FLUTTER_VERSION }}-

      - name: Cache Android Gradle dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
            android/.gradle
          key: v1-${{ runner.os }}-gradle-${{ hashFiles('**/gradle-wrapper.properties') }}-${{ hashFiles('**/*.gradle*', '**/libs.versions.toml', '**/gradle/libs.versions.toml') }}
          restore-keys: |
            v1-${{ runner.os }}-gradle-${{ hashFiles('**/gradle-wrapper.properties') }}-

      - name: Build Android
        run: |
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          echo "üîß Building Android $FLAVOR..."

          if [[ "${{ needs.prepare-release.outputs.is_staging }}" == "true" ]]; then
            echo "üì± Building APK for staging"
            flutter build apk --release \
              --flavor $FLAVOR \
              --dart-define-from-file=config/$FLAVOR.json \
              --split-debug-info=build/debug-info \
              --obfuscate
          else
            echo "üì¶ Building AAB for production"
            flutter build appbundle --release \
              --flavor $FLAVOR \
              --dart-define-from-file=config/$FLAVOR.json \
              --split-debug-info=build/debug-info \
              --obfuscate
          fi

      - name: Setup Firebase CLI (Staging)
        if: needs.prepare-release.outputs.flavor == 'staging'
        uses: w9jds/setup-firebase@main
        with:
          gcp_sa_key: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_STAGING }}

      - name: Setup Firebase CLI (Production)
        if: needs.prepare-release.outputs.flavor == 'production'
        uses: w9jds/setup-firebase@main
        with:
          gcp_sa_key: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_PROD }}

      - name: Upload symbols to Firebase Crashlytics
        run: |
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          echo "üîç Uploading debug symbols to Firebase Crashlytics for $FLAVOR..."

          # Determine Firebase App ID based on flavor
          if [[ "$FLAVOR" == "staging" ]]; then
            FIREBASE_APP_ID="${{ steps.load-versions.outputs.FIREBASE_ANDROID_STAGING_APP_ID }}"
          else
            FIREBASE_APP_ID="${{ steps.load-versions.outputs.FIREBASE_ANDROID_PROD_APP_ID }}"
          fi

          # Upload symbols to Firebase Crashlytics
          firebase crashlytics:symbols:upload --app="$FIREBASE_APP_ID" build/debug-info

          echo "‚úÖ Debug symbols uploaded to Firebase Crashlytics for app: $FIREBASE_APP_ID"

      - name: Distribute to Firebase
        run: |
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          VERSION="${{ needs.prepare-release.outputs.version }}"
          TAG_NAME="${{ needs.prepare-release.outputs.tag_name }}"

          if [[ "$FLAVOR" == "staging" ]]; then
            APK_PATH="build/app/outputs/flutter-apk/app-staging-release.apk"

            firebase appdistribution:distribute "$APK_PATH" \
              --app "${{ steps.load-versions.outputs.FIREBASE_ANDROID_STAGING_APP_ID }}" \
              --groups "${{ secrets.FIREBASE_GROUPS_STAGING || 'internal-testers' }}" \
              --release-notes "Pre-release $TAG_NAME from commit ${{ github.sha }}"
          else
            AAB_PATH="build/app/outputs/bundle/release/app-production-release.aab"

            firebase appdistribution:distribute "$AAB_PATH" \
              --app "${{ steps.load-versions.outputs.FIREBASE_ANDROID_PROD_APP_ID }}" \
              --groups "${{ secrets.FIREBASE_GROUPS_PROD || 'production-testers' }}" \
              --release-notes "Production release $TAG_NAME from commit ${{ github.sha }}"
          fi

  # Job 4: Create unified release
  create-unified-release:
    name: Create Unified Release
    runs-on: ubuntu-latest
    needs: [prepare-release, build-ios, build-android]
    if: always() && needs.build-ios.result == 'success' && needs.build-android.result == 'success'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare release files
        run: |
          VERSION="${{ needs.prepare-release.outputs.version }}"
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          TAG_NAME="${{ needs.prepare-release.outputs.tag_name }}"
          mkdir -p release-files

          # iOS: Utiliser le script Codemagic existant pour t√©l√©charger l'IPA
          BUILD_INFO="${{ needs.build-ios.outputs.final_build_info }}"
          ./scripts/download-codemagic-artifacts.sh "$BUILD_INFO" "ios-artifacts-temp"
          IOS_IPA=$(find ios-artifacts-temp -name "*.ipa" | head -1)
          if [[ -n "$IOS_IPA" ]]; then
            cp "$IOS_IPA" "release-files/edulift-$FLAVOR.ipa"
            echo "‚úÖ iOS IPA: $(basename $IOS_IPA)"
          else
            echo "‚ùå No iOS IPA found"
            exit 1
          fi

          # Android: Utiliser les fichiers locaux construits dans build-android (pas d'artifacts)
          if [[ "$FLAVOR" == "staging" ]]; then
            ANDROID_FILE="build/app/outputs/flutter-apk/app-staging-release.apk"
            TARGET_FILE="edulift-$FLAVOR.apk"
          else
            ANDROID_FILE="build/app/outputs/bundle/release/app-production-release.aab"
            TARGET_FILE="edulift-$FLAVOR.aab"
          fi

          if [[ -f "$ANDROID_FILE" ]]; then
            cp "$ANDROID_FILE" "release-files/$TARGET_FILE"
            echo "‚úÖ Android: $(basename $ANDROID_FILE)"
          else
            echo "‚ùå No Android file found: $ANDROID_FILE"
            exit 1
          fi

          echo "üì¶ Final release files:"
          ls -la release-files/

      - name: Create unified GitHub release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.prepare-release.outputs.tag_name }}
          name: EduLift Mobile ${{ needs.prepare-release.outputs.flavor }} ${{ needs.prepare-release.outputs.version }}
          body: |
            EduLift Mobile ${{ needs.prepare-release.outputs.flavor }} release

            **Version:** ${{ needs.prepare-release.outputs.version }}
            **Platform:** iOS + Android (Unified)
            **Environment:** ${{ needs.prepare-release.outputs.flavor }}
            **Commit:** ${{ github.sha }}
            **Build:** ${{ github.run_number }}

            ## üì± Downloads

            **iOS (AltStore PAL):**
            - üì¶ `edulift-${{ needs.prepare-release.outputs.flavor }}.ipa`
            - Unsigned build for AltStore PAL distribution

            **Android:**
            ${{ needs.prepare-release.outputs.is_staging == 'true' && '- üì¶ `edulift-staging.apk`\n- For Firebase App Distribution testing' || '- üì¶ `edulift-production.aab`\n- For Google Play Store release' }}

            ## üîó Links

            - **Download:** Click assets below ‚¨áÔ∏è
            - **Commit:** [${{ github.sha }}](https://github.com/${{ github.repository }}/commit/${{ github.sha }})
            ${{ needs.prepare-release.outputs.is_staging == 'true' && '- **Testing:** Firebase App Distribution' || '- **Store:** Google Play Console' }}

          files: release-files/*
          draft: false
          prerelease: ${{ needs.prepare-release.outputs.is_staging }}
          generate_release_notes: true

      - name: Get download URL for AltStore
        id: urls
        run: |
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          TAG_NAME="${{ needs.prepare-release.outputs.tag_name }}"

          IPA_DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/$TAG_NAME/edulift-$FLAVOR.ipa"

          echo "ipa_download_url=$IPA_DOWNLOAD_URL" >> $GITHUB_OUTPUT
          echo "üîó IPA Download URL: $IPA_DOWNLOAD_URL"

      - name: Update AltStore PAL source
        run: |
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          IPA_PATH="release-files/edulift-$FLAVOR.ipa"
          DOWNLOAD_URL="${{ steps.urls.outputs.ipa_download_url }}"

          echo "üì± Updating AltStore PAL source..."
          echo "   Flavor: $FLAVOR"
          echo "   IPA: $IPA_PATH"
          echo "   Download URL: $DOWNLOAD_URL"

          # Setup git for AltStore repo updates
          ALTSTORE_REPO="jrevillard/my-altstore"
          ALTSTORE_BRANCH="main"

          mkdir -p altstore_temp
          cd altstore_temp

          # Clone AltStore repo
          if [[ -n "${{ secrets.GITHUB_TOKEN }}" ]]; then
            git clone https://${{ secrets.GITHUB_TOKEN }}@github.com/$ALTSTORE_REPO.git .
          else
            git clone https://github.com/$ALTSTORE_REPO.git .
          fi

          git checkout $ALTSTORE_BRANCH

          # Get app info from pre-extracted version
          VERSION="${{ needs.prepare-release.outputs.version }}"
          BUILD_NUMBER="${{ github.run_number }}"
          IPA_SIZE=$(du -h "../$IPA_PATH" | cut -f1)

          # Generate AltStore PAL JSON
          mkdir -p apps
          APP_JSON="apps/${FLAVOR}.json"

          # Use jq to generate JSON safely
          jq -n \
            --arg name "EduLift" \
            --arg bundleId "com.edulift.app${FLAVOR:+:.staging}" \
            --arg version "$VERSION" \
            --arg versionDate "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --arg localizedDescription "Version $VERSION - Build $BUILD_NUMBER" \
            --arg downloadURL "$DOWNLOAD_URL" \
            --arg size "$IPA_SIZE" \
            --arg iconURL "https://raw.githubusercontent.com/jrevillard/edulift-mobile/main/docs/edulift-icon.png" \
            --arg tintColor "#1976d2" \
            '{
              "name": $name,
              "bundleIdentifier": $bundleId,
              "version": $version,
              "versionDate": $versionDate,
              "localizedDescription": $localizedDescription,
              "downloadURL": $downloadURL,
              "size": ($size | tonumber),
              "iconURL": $iconURL,
              "tintColor": $tintColor
            }' > "$APP_JSON"

          echo "‚úÖ Generated $APP_JSON:"
          echo "   Name: EduLift $FLAVOR"
          echo "   Bundle ID: com.edulift.app${FLAVOR:+:.staging}"
          echo "   Download URL: $DOWNLOAD_URL"
          echo "   Size: $IPA_SIZE"

          # Commit and push
          git config user.name "GitHub Actions"
          git config user.email "action@github.com"

          if git diff --quiet; then
            echo "‚ÑπÔ∏è No changes to AltStore source"
          else
            git add .
            git commit -m "feat: update EduLift $FLAVOR to version $VERSION"
            git push origin $ALTSTORE_BRANCH
            echo "‚úÖ AltStore PAL source updated"
          fi

          cd ..
          rm -rf altstore_temp

      - name: Release summary
        run: |
          echo "üéâ Unified release completed!"
          echo ""
          echo "üìã Release Details:"
          echo "   Tag: ${{ needs.prepare-release.outputs.tag_name }}"
          echo "   Version: ${{ needs.prepare-release.outputs.version }}"
          echo "   Environment: ${{ needs.prepare-release.outputs.flavor }}"
          echo "   Platforms: iOS + Android"
          echo "   AltStore: ‚úÖ Updated"
          echo ""
          echo "üîó View release: https://github.com/${{ github.repository }}/releases/tag/${{ needs.prepare-release.outputs.tag_name }}"

      - name: Reset pubspec.yaml for development
        if: success()  # Only run if all previous steps succeeded
        run: |
          set -e
          echo "üîÑ Resetting pubspec.yaml for development after successful release..."

          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          TARGET_BRANCH="main"

          echo "üîÑ Fetching target branch '$TARGET_BRANCH'..."
          git fetch origin $TARGET_BRANCH

          echo "üìã Checking out '$TARGET_BRANCH'..."
          git checkout $TARGET_BRANCH

          echo "üîÑ Resetting local branch to match remote..."
          git reset --hard origin/$TARGET_BRANCH

          # Reset pubspec.yaml to development version after successful release
          BASE_VERSION="${{ needs.prepare-release.outputs.base_version }}"

          # Calculate next patch version for development
          # Example: 0.1.0 ‚Üí 0.1.1-dev+1
          NEXT_PATCH=$(echo "$BASE_VERSION" | awk -F. '{print $1"."$2"."($3+1)}')
          DEV_VERSION="${NEXT_PATCH}-dev+1"

          sed -i "s/^version: .*/version: $DEV_VERSION/" pubspec.yaml
          echo "üî¢ Development version calculated: $DEV_VERSION (from $BASE_VERSION)"

          # Commit the development version reset
          git add pubspec.yaml
          git commit -m " [skip ci] chore: reset pubspec.yaml to development version $DEV_VERSION"
          git push origin $TARGET_BRANCH

          echo "‚úÖ Successfully reset pubspec.yaml to development version: $DEV_VERSION"
          echo "üöÄ Ready for next development cycle!"

  # Job 5: Handle build failures (notification)
  handle-failures:
    name: Handle Build Failures
    runs-on: ubuntu-latest
    needs: [prepare-release, build-ios, build-android]
    if: always() && (needs.build-ios.result == 'failure' || needs.build-android.result == 'failure')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Notify build failures
        run: |
          echo "‚ùå Build failures detected!"
          echo ""
          echo "üìã Build Status Summary:"
          echo "   Prepare Release: ${{ needs.prepare-release.result }}"
          echo "   Build iOS: ${{ needs.build-ios.result }}"
          echo "   Build Android: ${{ needs.build-android.result }}"
          echo ""

          if [[ "${{ needs.build-ios.result }}" == "failure" ]]; then
            echo "üîç iOS build failed - check Codemagic logs"
          fi

          if [[ "${{ needs.build-android.result }}" == "failure" ]]; then
            echo "üîç Android build failed - check GitHub Actions logs"
          fi

          echo "üîó Monitor builds:"
          echo "   GitHub Actions: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          if [[ -n "${{ vars.CODEMAGIC_APP_ID }}" ]]; then
            echo "   Codemagic: https://codemagic.io/app/${{ vars.CODEMAGIC_APP_ID }}/builds"
          fi
