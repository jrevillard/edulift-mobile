# .github/workflows/cd.yml - Mobile Unified Release System
#
# OVERVIEW:
# =========
# This workflow implements a unified release system that coordinates iOS builds (via Codemagic)
# and Android builds (via GitHub Actions) using a branch-based approach.
#
# TRIGGER:
# =======
# - push to branches matching pattern: 'release/*'
# - Validates semantic version format (e.g., 2.1.0, 2.1.0-beta2, 2.1.0-rc1)
# - Rejects invalid branch names (test, fix, hotfix, experimental, wip, temp)
#
# WORKFLOW FLOW:
# ===============
# 1. prepare-release: Extract version, update pubspec.yaml, create git tag, merge to main
# 2. build-ios: Trigger Codemagic build, wait completion, download artifacts
# 3. build-android: Build APK/AAB in parallel
# 4. create-unified-release: Create GitHub release, update AltStore PAL source
# 5. handle-failures: Notify on build failures
#
# SECURITY:
# ==========
# - Semantic version regex validation prevents unauthorized releases
# - All secrets properly stored in GitHub Actions secrets
# - No hardcoded credentials in any scripts or configurations
# - Fail-fast on any validation errors
#
# ARCHITECTURE:
# ============
# - GitHub Actions: Central coordinator and version management
# - Codemagic: Build-only iOS execution (no version management conflicts)
# - AltStore PAL: Automatic source updates for iOS distribution
# - Firebase: App Distribution integration for testing
#
name: Mobile Unified Release

permissions:
  contents: write
  pull-requests: write

on:
  push:
    branches:
      - 'release/*'

env:
  # Flutter configuration
  FLUTTER_VERSION: ${{ vars.FLUTTER_VERSION || '3.38.2' }}
  JAVA_VERSION: ${{ vars.JAVA_VERSION || '17' }}

jobs:
  # Job 1: Prepare release environment
  prepare-release:
    name: Prepare Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      flavor: ${{ steps.version.outputs.flavor }}
      tag_name: ${{ steps.version.outputs.tag_name }}
      is_staging: ${{ steps.version.outputs.is_staging }}
      base_version: ${{ steps.version.outputs.base_version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Load CI/CD versions
        id: load-versions
        run: |
          if [[ -f ".github/ci-versions.env" ]]; then
            while IFS='=' read -r key value; do
              # Skip empty lines and comments
              if [[ -n "$key" && ! "$key" =~ ^[[:space:]]*# ]]; then
                echo "$key=$value" >> $GITHUB_OUTPUT
              fi
            done < .github/ci-versions.env
          fi

      - name: Validate version format
        id: validate-version
        run: |
          BRANCH_NAME="${GITHUB_REF_NAME}"
          echo "Processing release branch: $BRANCH_NAME"

          # Extract version from branch name (remove 'release/' prefix)
          VERSION="${BRANCH_NAME#release/}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

          # Validate semantic version format
          # Patterns:
          # - 2.1.0 (production)
          # - 2.1.0-alpha1, 2.1.0-beta2, 2.1.0-rc1 (staging)
          if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-((alpha|beta|rc)[0-9]*))?$ ]]; then
            echo "ERROR:  Invalid version format: $VERSION"
            echo ""
            echo "Expected formats:"
            echo "  - 2.1.0 (production)"
            echo "  - 2.1.0-alpha1 (staging)"
            echo "  - 2.1.0-beta2 (staging)"
            echo "  - 2.1.0-rc1 (staging)"
            echo ""
            echo "Rejected: test, fix, hotfix, bugfix, experimental, wip, temp, etc."
            echo ""
            echo "Please use semantic versioning format in release/ branches."
            exit 1
          fi

          # Extract base version (remove pre-release)
          BASE_VERSION=$(echo "$VERSION" | sed -E 's/(-alpha|-beta|-rc).*//')
          echo "base_version=$BASE_VERSION" >> $GITHUB_OUTPUT

          # Create tag name for later use
          TAG_NAME="v$VERSION"
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

          # Determine flavor from version pattern
          if [[ "$VERSION" =~ (alpha|beta|rc) ]]; then
            FLAVOR="staging"
            IS_STAGING="true"
          else
            FLAVOR="production"
            IS_STAGING="false"
          fi

          echo "flavor=$FLAVOR" >> $GITHUB_OUTPUT
          echo "is_staging=$IS_STAGING" >> $GITHUB_OUTPUT

          echo "SUCCESS:  Version format validated: $VERSION"
          echo "INFO:  Release Info:"
          echo "   Branch: $BRANCH_NAME"
          echo "   Version: $VERSION"
          echo "   Tag: $TAG_NAME"
          echo "   Base Version: $BASE_VERSION"
          echo "   Flavor: $FLAVOR"
          echo "   Staging: $IS_STAGING"

      - name: Extract version and flavor from branch
        id: version
        run: |
          # This step now just passes through the validated values
          echo "version=${{ steps.validate-version.outputs.version }}" >> $GITHUB_OUTPUT
          echo "base_version=${{ steps.validate-version.outputs.base_version }}" >> $GITHUB_OUTPUT
          echo "tag_name=${{ steps.validate-version.outputs.tag_name }}" >> $GITHUB_OUTPUT
          echo "flavor=${{ steps.validate-version.outputs.flavor }}" >> $GITHUB_OUTPUT
          echo "is_staging=${{ steps.validate-version.outputs.is_staging }}" >> $GITHUB_OUTPUT

      - name: Check if release already exists
        id: check-release
        run: |
          TAG_NAME="${{ steps.version.outputs.tag_name }}"
          VERSION="${{ steps.version.outputs.version }}"
          BRANCH_NAME="${GITHUB_REF_NAME}"

          echo " Checking if release $TAG_NAME already exists..."

          # Check if tag already exists
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "ERROR:  Release $TAG_NAME already exists!"
            echo "üö´ This version has already been released."
            echo ""
            echo "INFO:  To rebuild this release:"
            echo "   git tag -d $TAG_NAME"
            echo "   git push origin --delete $TAG_NAME"
            echo "   Then re-run the workflow"
            echo ""
            echo "üéØ Skipping build to avoid duplicate release"
            exit 1
          fi

      - name: Update pubspec.yaml
        run: |
          # Use run number as build number
          BUILD_NUMBER="${{ github.run_number }}"
          BASE_VERSION="${{ steps.version.outputs.base_version }}"

          sed -i "s/^version: .*/version: $BASE_VERSION+$BUILD_NUMBER/" pubspec.yaml

          echo "SUCCESS:  Updated pubspec.yaml:"
          grep "^version:" pubspec.yaml

      - name: Commit version update
        run: |
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Add and commit version update
          git add pubspec.yaml
          git commit -m "[skip ci] chore: update version to ${{ steps.version.outputs.base_version }}+${{ github.run_number }}"

          # Push commit to release branch (force-with-lease for safety)
          git push origin release/${{ steps.version.outputs.version }} --force-with-lease

          echo "SUCCESS:  Committed version update to release/${{ steps.version.outputs.version }}"

      - name: Merge to main and create tag
        run: |
          set -e

          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          TARGET_BRANCH="main"
          RELEASE_BRANCH="release/${{ steps.version.outputs.version }}"
          TAG_NAME="${{ steps.version.outputs.tag_name }}"

          echo "üîÑ Fetching target branch..."
          git fetch origin $TARGET_BRANCH

          echo "INFO:  Checking out '$TARGET_BRANCH'..."
          git checkout $TARGET_BRANCH

          echo "üîÄ Merging '$RELEASE_BRANCH' into '$TARGET_BRANCH'..."
          git merge origin/$RELEASE_BRANCH --no-ff -m "[skip ci] chore(release): Release ${{ steps.version.outputs.version }}"

          echo "üì§ Pushing merge to '$TARGET_BRANCH'..."
          git push origin $TARGET_BRANCH

          echo "üè∑Ô∏è Creating tag '$TAG_NAME' on '$TARGET_BRANCH'..."
          git tag -a "$TAG_NAME" -m "Release ${{ steps.version.outputs.version }}"
          git push origin "$TAG_NAME"

          echo "üßπ Cleaning up release branch '$RELEASE_BRANCH'..."
          git push origin --delete "$RELEASE_BRANCH"

          echo "SUCCESS:  Successfully merged $RELEASE_BRANCH to $TARGET_BRANCH"
          echo "SUCCESS:  Created and pushed tag: $TAG_NAME"
          echo "SUCCESS:  Deleted release branch: $RELEASE_BRANCH"

  # Job 2: Build iOS (trigger Codemagic)
  build-ios:
    name: Build iOS
    runs-on: ubuntu-latest
    needs: prepare-release
    outputs:
      final_build_info: ${{ steps.wait-ios.outputs.build_info }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Trigger Codemagic iOS build
        id: trigger-ios
        env:
          CODEMAGIC_API_TOKEN: ${{ secrets.CODEMAGIC_API_TOKEN }}
        run: |
          # Map flavor to workflow ID
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          if [[ "$FLAVOR" == "staging" ]]; then
            WORKFLOW_ID="ios-staging"
          elif [[ "$FLAVOR" == "production" ]]; then
            WORKFLOW_ID="ios-production"
          else
            echo "ERROR:  Unknown flavor: $FLAVOR"
            exit 1
          fi

          ./scripts/trigger-codemagic-api.sh \
            "${{ vars.CODEMAGIC_APP_ID }}" \
            "$WORKFLOW_ID" \
            "main" \
            "${{ needs.prepare-release.outputs.tag_name }}"

      - name: Wait for iOS build completion
        id: wait-ios
        env:
          CODEMAGIC_API_TOKEN: ${{ secrets.CODEMAGIC_API_TOKEN }}
        run: |
          ./scripts/wait-codemagic-build.sh \
            "${{ steps.trigger-ios.outputs.BUILD_ID }}" \
            "1800" "30"  # 30 minutes max, 30 second polling

      - name: Validate build info availability
        env:
          BUILD_INFO: ${{ steps.wait-ios.outputs.build_info }}
        run: |
          echo "Checking build info availability..."

          # Verify build_info is available and valid
          if [[ -z "$BUILD_INFO" ]]; then
            echo "ERROR:  Build info not available - build polling may have failed"
            echo "INFO:  This usually means the wait-codemagic-build.sh script did not complete properly"
            echo "LINK:  Check the previous step logs for build polling errors"
            exit 1
          fi

          # Validate build info JSON format using safer approach
          if ! printf '%s\n' "$BUILD_INFO" | jq -e '.build.artefacts' >/dev/null 2>&1; then
            echo "ERROR:  Invalid build info JSON format - build polling may have failed"
            echo "DATA:  Build info content (first 500 chars):"
            printf '%s\n' "$BUILD_INFO" | head -c 500
            echo ""
            echo "INFO:  The build info should be valid JSON with 'build.artefacts' array"
            exit 1
          fi

          echo "SUCCESS:  Build info validated successfully"
          echo "DATA:  Build status: $(printf '%s\n' "$BUILD_INFO" | jq -r '.build.status')"
          echo "FILES:  Artifact count: $(printf '%s\n' "$BUILD_INFO" | jq -r '.build.artefacts | length')"

  # Job 3: Build Android (parallel)
  build-android:
    name: Build Android
    runs-on: ubuntu-latest
    needs: prepare-release
    outputs:
      download_url: ${{ steps.firebase-upload.outputs.download_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Load CI/CD versions
        id: load-versions
        run: |
          if [[ -f ".github/ci-versions.env" ]]; then
            while IFS='=' read -r key value; do
              # Skip empty lines and comments
              if [[ -n "$key" && ! "$key" =~ ^[[:space:]]*# ]]; then
                echo "$key=$value" >> $GITHUB_OUTPUT
              fi
            done < .github/ci-versions.env
          fi

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ steps.load-versions.outputs.FLUTTER_VERSION }}
          channel: ${{ steps.load-versions.outputs.FLUTTER_CHANNEL }}
          cache: true

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ steps.load-versions.outputs.JAVA_VERSION }}

      - name: Cache Flutter dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.pub-cache
          key: v1-${{ runner.os }}-flutter-${{ steps.load-versions.outputs.FLUTTER_VERSION }}-${{ hashFiles('**/pubspec.lock') }}
          restore-keys: |
            v1-${{ runner.os }}-flutter-${{ steps.load-versions.outputs.FLUTTER_VERSION }}-

      - name: Cache Android Gradle dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
            android/.gradle
          key: v1-${{ runner.os }}-gradle-${{ hashFiles('**/gradle-wrapper.properties') }}-${{ hashFiles('**/*.gradle*', '**/libs.versions.toml', '**/gradle/libs.versions.toml') }}
          restore-keys: |
            v1-${{ runner.os }}-gradle-${{ hashFiles('**/gradle-wrapper.properties') }}-

      - name: Configure Android keystore
        env:
          ANDROID_KEYSTORE: ${{ secrets.ANDROID_KEYSTORE }}
          KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
        run: |
          echo "üîê Configuring Android keystore for release signing..."

          # Decode keystore from base64 and save as JKS file
          echo "$ANDROID_KEYSTORE" | base64 --decode > android/app/edulift-release.keystore

          # Verify the decoded file
          echo "üîç Verifying keystore file..."
          if [ ! -f "android/app/edulift-release.keystore" ]; then
            echo "‚ùå ERROR: Keystore file was not created!"
            exit 1
          fi

          # Check file size and type
          KEYSTORE_SIZE=$(stat -c%s "android/app/edulift-release.keystore")
          echo "INFO:  Keystore file size: $KEYSTORE_SIZE bytes"

          # For JKS keystore, keypass might not be used or equals storepass
          # Try both keypass and storepass for the key password
          echo "INFO:  Keystore format: JKS (Java Keystore)"
          echo "INFO:  Key alias: $KEY_ALIAS"

          # Create key.properties file in android/ directory
          # storeFile path is relative to android/app/ (where build.gradle.kts is located)
          # Use printf to safely handle special characters in passwords
          printf "storeFile=%s\n" "edulift-release.keystore" > android/key.properties
          printf "keyAlias=%s\n" "$KEY_ALIAS" >> android/key.properties

          # For JKS, use keyPassword first, fallback to storePassword if needed
          if [ -n "$KEY_PASSWORD" ] && [ "$KEY_PASSWORD" != "" ]; then
            printf "keyPassword=%s\n" "$KEY_PASSWORD" >> android/key.properties
            echo "INFO:  Using KEY_PASSWORD for key password"
          else
            printf "keyPassword=%s\n" "$KEYSTORE_PASSWORD" >> android/key.properties
            echo "INFO:  Using KEYSTORE_PASSWORD for key password (JKS fallback)"
          fi

          printf "storePassword=%s\n" "$KEYSTORE_PASSWORD" >> android/key.properties
          # No storeType needed for JKS (default)

          echo "‚úÖ Keystore configured successfully"
          echo "INFO:  Keystore location: android/app/edulift-release.keystore"
          echo "INFO:  Keystore type: JKS (Java Keystore)"
          echo "INFO:  Properties file: android/key.properties"
          echo "INFO:  storeFile path: edulift-release.keystore (relative to android/app/)"

      - name: Build Android
        run: |
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          echo "BUILD:  Building Android $FLAVOR..."

          if [[ "${{ needs.prepare-release.outputs.is_staging }}" == "true" ]]; then
            echo "ANDROID:  Building APK for staging"
            flutter build apk --release \
              --flavor $FLAVOR \
              --dart-define-from-file=config/$FLAVOR.json \
              --split-debug-info=build/debug-info \
              --obfuscate \
              --tree-shake-icons
          else
            echo "FILES:  Building AAB for production"
            flutter build appbundle --release \
              --flavor $FLAVOR \
              --dart-define-from-file=config/$FLAVOR.json \
              --split-debug-info=build/debug-info \
              --obfuscate \
              --tree-shake-icons
          fi

          echo "INFO:  Build artifacts generated:"
          echo "   APK/AAB: build/app/outputs/"
          echo ""
          echo "üîç DEBUG: Checking build directory structure..."

          # List build directory contents for debugging
          echo "DEBUG: build/ directory contents:"
          find build -type f -name "*.symbols" -o -name "*.map" -o -name "*.info" 2>/dev/null | head -10 || echo "         No debug symbols found"

          echo "DEBUG: build directory structure:"
          find build -type d | head -10 || echo "         No build directories found"

          echo "DEBUG: build/ size:"
          du -sh build 2>/dev/null || echo "         Cannot access build directory"

          echo "DEBUG: Current working directory:"
          pwd

          echo "DEBUG: Runner environment:"
          echo "   Runner OS: $(uname -a)"
          echo "   Disk space: $(df -h . | tail -1)"
          echo "   Memory: $(free -h | grep Mem)"
          echo "   Flutter version: $(flutter --version | head -1)"
          echo "   Build directory permissions: $(ls -la build/ 2>/dev/null | head -5 || echo 'Cannot access build/')"

          echo "DEBUG: build/debug-info exists:"
          if [[ -d "build/debug-info" ]]; then
            echo "         ‚úÖ Directory exists"
            echo "DEBUG: build/debug-info contents:"
            ls -la build/debug-info/ | head -10
            echo "DEBUG: build/debug-info size:"
            du -sh build/debug-info/
          else
            echo "         ‚ùå Directory does NOT exist"
            echo "DEBUG: Looking for alternative debug info locations:"
            find . -name "*debug*" -type d 2>/dev/null | head -5
            find . -name "*.symbols" -type f 2>/dev/null | head -5
          fi

      - name: Setup Firebase CLI (Staging)
        if: needs.prepare-release.outputs.flavor == 'staging'
        uses: w9jds/setup-firebase@main
        with:
          gcp_sa_key: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_STAGING }}

      - name: Setup Firebase CLI (Production)
        if: needs.prepare-release.outputs.flavor == 'production'
        uses: w9jds/setup-firebase@main
        with:
          gcp_sa_key: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_PROD }}

      - name: Upload symbols to Firebase Crashlytics
        run: |
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          echo " Uploading debug symbols to Firebase Crashlytics for $FLAVOR..."

          # Determine Firebase App ID based on flavor
          if [[ "$FLAVOR" == "staging" ]]; then
            FIREBASE_APP_ID="${{ steps.load-versions.outputs.FIREBASE_ANDROID_STAGING_APP_ID }}"
          else
            FIREBASE_APP_ID="${{ steps.load-versions.outputs.FIREBASE_ANDROID_PROD_APP_ID }}"
          fi

          # Check if debug symbols exist before uploading
          if [[ -d "build/debug-info" ]] && [[ "$(ls -A build/debug-info 2>/dev/null)" ]]; then
            echo "INFO:  Uploading debug symbols with obfuscation mappings to Firebase Crashlytics..."
            echo "INFO:  Debug symbols directory contents:"
            ls -lh build/debug-info/

            # Upload all .symbols files - these contain BOTH debug info AND obfuscation mappings
            # Flutter generates .symbols files (NOT .map files) that include embedded obfuscation data
            if firebase crashlytics:symbols:upload --app="$FIREBASE_APP_ID" build/debug-info/; then
              echo "SUCCESS:  Debug symbols uploaded (includes obfuscation mappings)"

              # Verify upload with Firebase CLI
              echo "INFO:  Verifying symbol upload..."
              firebase crashlytics:mappingfile:list --app="$FIREBASE_APP_ID" | tail -5 || echo "INFO:  Verification skipped (CLI limitation)"
            else
              echo "WARNING: Symbol upload failed - continuing without Crashlytics symbols"
              echo "IMPACT:  Production crashes will be harder to debug (no de-obfuscation)"
              echo "INFO:    Release will continue normally - APK/AAB deployment not blocked"
            fi

            # Check for native symbols (if using NDK or native plugins)
            NATIVE_LIBS_DIR="build/app/intermediates/merged_native_libs/${FLAVOR}/release/out/lib"
            if [[ -d "$NATIVE_LIBS_DIR" ]] && [[ "$(find "$NATIVE_LIBS_DIR" -name "*.so" 2>/dev/null)" ]]; then
              echo "INFO:  Found native symbols, uploading from: $NATIVE_LIBS_DIR"
              firebase crashlytics:symbols:upload --app="$FIREBASE_APP_ID" "$NATIVE_LIBS_DIR" || echo "WARNING:  Native symbol upload failed (non-critical if no NDK plugins)"
            else
              echo "INFO:  No native symbols found (this is normal if not using NDK plugins)"
            fi

            echo "SUCCESS:  Crashlytics symbol upload completed"
            echo "INFO:  Production crashes can now be properly analyzed and de-obfuscated"
          else
            echo "WARNING: No debug symbols found - continuing without Crashlytics symbols"
            echo "INFO:    APK/AAB will still be uploaded to Firebase App Distribution"
            echo "REASON:  This is a known CI environment issue with Flutter --split-debug-info"
            echo "IMPACT:  Production crashes will be harder to debug but app works normally"
            echo ""
            echo "DIAGNOSTICS:"
            echo "  - build/debug-info/ directory was not created by Flutter build"
            echo "  - Symbols work locally but not in CI (environment-specific issue)"
            echo "  - Native symbols may still be available in build/intermediates/"
            echo ""
            echo "NEXT STEPS:"
            echo "  1. Monitor app stability through Firebase App Distribution"
            echo "  2. Investigate CI environment differences (Flutter config, env vars)"
            echo "  3. Debug symbols can be generated locally if needed for crash analysis"
          fi

  
      - name: Distribute to Firebase
        id: firebase-upload
        run: |
          set -e  # Exit on any error

          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          VERSION="${{ needs.prepare-release.outputs.version }}"
          TAG_NAME="${{ needs.prepare-release.outputs.tag_name }}"

          # Determine file paths and verify existence
          if [[ "$FLAVOR" == "staging" ]]; then
            ARTIFACT_PATH="build/app/outputs/flutter-apk/app-staging-release.apk"
            ARTIFACT_TYPE="APK"
          else
            ARTIFACT_PATH="build/app/outputs/bundle/productionRelease/app-production-release.aab"
            ARTIFACT_TYPE="AAB"
          fi

          # Verify artifact exists before upload
          if [[ ! -f "$ARTIFACT_PATH" ]]; then
            echo "ERROR: $ARTIFACT_TYPE file not found: $ARTIFACT_PATH"
            echo "DEBUG: Available files in build/app/outputs:"
            find build/app/outputs -type f 2>/dev/null || echo "No files found"
            exit 1
          fi

          FILE_SIZE=$(stat -c%s "$ARTIFACT_PATH")
          echo "INFO:  Found $ARTIFACT_TYPE: $ARTIFACT_PATH ($FILE_SIZE bytes)"

          # Upload to Firebase with proper error handling
          echo "INFO:  Uploading $ARTIFACT_TYPE to Firebase App Distribution..."

          if [[ "$FLAVOR" == "staging" ]]; then
            UPLOAD_OUTPUT=$(firebase appdistribution:distribute "$ARTIFACT_PATH" \
              --app "${{ steps.load-versions.outputs.FIREBASE_ANDROID_STAGING_APP_ID }}" \
              --groups "${{ secrets.FIREBASE_GROUPS_STAGING || 'internal-testers' }}" \
              --release-notes "Pre-release $TAG_NAME from commit ${{ github.sha }}" 2>&1) || {
              echo "ERROR: Firebase upload failed"
              echo "DEBUG: Firebase CLI output:"
              echo "$UPLOAD_OUTPUT"
              exit 1
            }
          else
            UPLOAD_OUTPUT=$(firebase appdistribution:distribute "$ARTIFACT_PATH" \
              --app "${{ steps.load-versions.outputs.FIREBASE_ANDROID_PROD_APP_ID }}" \
              --groups "${{ secrets.FIREBASE_GROUPS_PROD || 'production-testers' }}" \
              --release-notes "Production release $TAG_NAME from commit ${{ github.sha }}" 2>&1) || {
              echo "ERROR: Firebase upload failed"
              echo "DEBUG: Firebase CLI output:"
              echo "$UPLOAD_OUTPUT"
              exit 1
            }
          fi

          # Display upload output for debugging
          echo "INFO:  Firebase upload completed"
          echo "DEBUG: Firebase CLI output:"
          echo "$UPLOAD_OUTPUT"

          # Extract download URL from Firebase CLI output
          # More robust pattern anchored to Firebase domains (immune to CLI text changes)
          # Matches: https://firebasestorage.googleapis.com/... OR https://firebaseappdistribution.googleapis.com/...
          DOWNLOAD_URL=$(echo "$UPLOAD_OUTPUT" | grep -oP '.*: \K(https?://(firebasestorage|firebaseappdistribution)\.googleapis\.com[^\s]+)' | head -1)

          if [[ -z "$DOWNLOAD_URL" ]]; then
            echo "ERROR: Failed to extract download URL from Firebase CLI output"
            echo "DEBUG: Full Firebase CLI output:"
            echo "$UPLOAD_OUTPUT"
            echo ""
            echo "INFO:  This could mean:"
            echo "  1. Firebase CLI output format changed"
            echo "  2. Upload succeeded but URL extraction regex needs updating"
            echo "  3. Firebase authentication issue"
            exit 1
          fi

          # Validate URL format (early detection of regex issues)
          if [[ ! "$DOWNLOAD_URL" =~ ^https://(firebasestorage|firebaseappdistribution)\.googleapis\.com/ ]]; then
            echo "WARNING: Unexpected URL format: $DOWNLOAD_URL"
            echo "INFO:  Expected URL starting with: https://firebasestorage.googleapis.com/ or https://firebaseappdistribution.googleapis.com/"
          fi

          echo "SUCCESS: Extracted download URL: $DOWNLOAD_URL"
          echo "INFO:  URL generated at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "INFO:  URL expires at: $(date -u -d '+1 hour' '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || echo 'N/A (date calculation not available)')"
          echo "download_url=$DOWNLOAD_URL" >> $GITHUB_OUTPUT

  # Job 4: Create unified release
  create-unified-release:
    name: Create Unified Release
    runs-on: ubuntu-latest
    needs: [prepare-release, build-ios, build-android]
    if: always() && needs.build-ios.result == 'success' && needs.build-android.result == 'success'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Load CI/CD versions
        id: load-versions
        run: |
          if [[ -f ".github/ci-versions.env" ]]; then
            while IFS='=' read -r key value; do
              # Skip empty lines and comments
              if [[ -n "$key" && ! "$key" =~ ^[[:space:]]*# ]]; then
                echo "$key=$value" >> $GITHUB_OUTPUT
              fi
            done < .github/ci-versions.env
          fi

      - name: Setup Firebase CLI (Staging)
        if: needs.prepare-release.outputs.flavor == 'staging'
        uses: w9jds/setup-firebase@main
        with:
          gcp_sa_key: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_STAGING }}

      - name: Setup Firebase CLI (Production)
        if: needs.prepare-release.outputs.flavor == 'production'
        uses: w9jds/setup-firebase@main
        with:
          gcp_sa_key: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_PROD }}

      - name: Download Android artifacts from Firebase
        run: |
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          DOWNLOAD_URL="${{ needs.build-android.outputs.download_url }}"

          echo "üì± Downloading Android artifacts from Firebase App Distribution..."
          mkdir -p build/app/outputs/{flutter-apk,bundle/productionRelease}

          # Determine target path based on flavor
          if [[ "$FLAVOR" == "staging" ]]; then
            TARGET_PATH="build/app/outputs/flutter-apk/app-staging-release.apk"
          else
            TARGET_PATH="build/app/outputs/bundle/productionRelease/app-production-release.aab"
          fi

          echo "INFO:  Download URL: $DOWNLOAD_URL"
          echo "INFO:  Target path: $TARGET_PATH"

          # Download file directly using the URL from build-android job
          if wget -O "$TARGET_PATH" "$DOWNLOAD_URL" --timeout=600 --tries=3 --wait=5; then
            # Verify file was downloaded successfully
            if [[ -f "$TARGET_PATH" && -s "$TARGET_PATH" ]]; then
              FILE_SIZE=$(stat -c%s "$TARGET_PATH")
              echo "SUCCESS: Downloaded $(basename $TARGET_PATH) ($FILE_SIZE bytes)"
            else
              echo "ERROR: Downloaded file is empty or missing"
              exit 1
            fi
          else
            echo "ERROR: Failed to download from Firebase"
            echo "INFO:  Download URL may have expired (1 hour limit)"
            echo "INFO:  Check build-android job completed successfully"
            exit 1
          fi

      - name: Prepare release files
        env:
          BUILD_INFO: ${{ needs.build-ios.outputs.final_build_info }}
          CODEMAGIC_API_TOKEN: ${{ secrets.CODEMAGIC_API_TOKEN }}
        run: |
          VERSION="${{ needs.prepare-release.outputs.version }}"
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          TAG_NAME="${{ needs.prepare-release.outputs.tag_name }}"
          mkdir -p release-files

          # iOS: Utiliser le script Codemagic existant pour t√©l√©charger l'IPA
          ./scripts/download-codemagic-artifacts.sh "$BUILD_INFO" "ios-artifacts-temp"
          IOS_IPA=$(find ios-artifacts-temp -name "*.ipa" | head -1)
          if [[ -n "$IOS_IPA" ]]; then
            cp "$IOS_IPA" "release-files/edulift-$FLAVOR.ipa"
            echo "SUCCESS:  iOS IPA: $(basename $IOS_IPA)"
          else
            echo "ERROR:  No iOS IPA found"
            exit 1
          fi

          # Android: Fichiers t√©l√©charg√©s depuis les artifacts du job build-android
          if [[ "$FLAVOR" == "staging" ]]; then
            ANDROID_FILE="build/app/outputs/flutter-apk/app-staging-release.apk"
            TARGET_FILE="edulift-$FLAVOR.apk"
          else
            ANDROID_FILE="build/app/outputs/bundle/productionRelease/app-production-release.aab"
            TARGET_FILE="edulift-$FLAVOR.aab"
          fi

          # Verify artifact was downloaded correctly
          if [[ -f "$ANDROID_FILE" ]]; then
            FILE_SIZE=$(stat -c%s "$ANDROID_FILE")
            echo "SUCCESS:  Android artifact found: $(basename $ANDROID_FILE) ($FILE_SIZE bytes)"

            # Validate minimum file size (10MB)
            if [[ $FILE_SIZE -lt 10485760 ]]; then
              echo "WARNING:  Artifact seems unusually small (< 10MB) - may be corrupted"
            fi

            cp "$ANDROID_FILE" "release-files/$TARGET_FILE"
          else
            echo "ERROR:  No Android file found: $ANDROID_FILE"
            echo "Available files in build/app/outputs:"
            find build/app/outputs -type f -name "*.apk" -o -name "*.aab" 2>/dev/null || echo "No APK/AAB files found"
            exit 1
          fi

          echo "FILES:  Final release files:"
          ls -la release-files/

          # Final verification: ensure BOTH files exist before creating release
          echo ""
          echo "üîç Final verification before release creation:"
          EXPECTED_IPA="release-files/edulift-$FLAVOR.ipa"
          EXPECTED_APK="release-files/edulift-$FLAVOR.apk"
          EXPECTED_AAB="release-files/edulift-$FLAVOR.aab"

          if [[ ! -f "$EXPECTED_IPA" ]]; then
            echo "‚ùå ERROR: IPA file missing: $EXPECTED_IPA"
            exit 1
          fi

          if [[ "$FLAVOR" == "staging" ]]; then
            if [[ ! -f "$EXPECTED_APK" ]]; then
              echo "‚ùå ERROR: APK file missing: $EXPECTED_APK"
              exit 1
            fi
            echo "‚úÖ Both files ready: IPA + APK"
          else
            if [[ ! -f "$EXPECTED_AAB" ]]; then
              echo "‚ùå ERROR: AAB file missing: $EXPECTED_AAB"
              exit 1
            fi
            echo "‚úÖ Both files ready: IPA + AAB"
          fi

          echo "‚úÖ All release files verified and ready for atomic upload"

      - name: Delete existing release if present
        continue-on-error: true
        run: |
          TAG_NAME="${{ needs.prepare-release.outputs.tag_name }}"
          echo "üîç Checking if release $TAG_NAME already exists..."

          # Try to delete existing release (will fail silently if doesn't exist)
          if gh release delete "$TAG_NAME" --yes 2>/dev/null; then
            echo "‚úÖ Deleted existing release: $TAG_NAME"
          else
            echo "‚ÑπÔ∏è  No existing release found (this is normal for first-time releases)"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # IMPORTANT: Two-step release pattern required for GitHub release immutability
      # 1. Create DRAFT release (mutable) and upload all assets
      # 2. Publish draft ‚Üí becomes immutable
      # This prevents "Cannot upload assets to an immutable release" error
      # DO NOT combine steps or specify 'files' in publish step

      - name: Create draft release and upload assets
        id: create_draft
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.prepare-release.outputs.tag_name }}
          name: EduLift Mobile ${{ needs.prepare-release.outputs.flavor }} ${{ needs.prepare-release.outputs.version }}
          body: |
            EduLift Mobile ${{ needs.prepare-release.outputs.flavor }} release

            **Version:** ${{ needs.prepare-release.outputs.version }}
            **Platform:** iOS + Android (Unified)
            **Environment:** ${{ needs.prepare-release.outputs.flavor }}
            **Commit:** ${{ github.sha }}
            **Build:** ${{ github.run_number }}

            ## üì± Downloads

            **iOS (AltStore PAL):**
            - üì¶ `edulift-${{ needs.prepare-release.outputs.flavor }}.ipa`
            - Unsigned build for AltStore PAL distribution

            **Android:**
            ${{ needs.prepare-release.outputs.is_staging == 'true' && '- üì¶ `edulift-staging.apk` - For Firebase App Distribution testing' || '- üì¶ `edulift-production.aab`\n- For Google Play Store release' }}

            ## üîó Links

            - **Download:** Click assets below ‚¨áÔ∏è
            - **Commit:** [${{ github.sha }}](https://github.com/${{ github.repository }}/commit/${{ github.sha }})
            ${{ needs.prepare-release.outputs.is_staging == 'true' && '- **Testing:** Firebase App Distribution' || '- **Store:** Google Play Console' }}

          files: release-files/*
          draft: true
          prerelease: ${{ needs.prepare-release.outputs.is_staging }}
          generate_release_notes: true

      - name: Verify draft creation
        run: |
          if [ -z "${{ steps.create_draft.outputs.id }}" ]; then
            echo "‚ùå ERROR: Draft release creation failed"
            echo "INFO:  Check previous step logs for errors"
            exit 1
          fi
          echo "‚úÖ Draft release created successfully"
          echo "   Release ID: ${{ steps.create_draft.outputs.id }}"
          echo "   URL: ${{ steps.create_draft.outputs.url }}"

      - name: Publish release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.prepare-release.outputs.tag_name }}
          draft: false
          # All other fields (name, body, assets, prerelease) are preserved from the draft

      - name: Create release on my-altstore repo with IPA
        id: altstore_release
        env:
          GH_TOKEN: ${{ secrets.MY_ALTSTORE_TOKEN }}
        run: |
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          TAG_NAME="${{ needs.prepare-release.outputs.tag_name }}"
          IPA_PATH="release-files/edulift-$FLAVOR.ipa"
          ALTSTORE_REPO="jrevillard/my-altstore"

          echo "üì¶ Creating release on $ALTSTORE_REPO..."
          echo "   Tag: $TAG_NAME"
          echo "   IPA: $IPA_PATH"

          # Delete existing release if present (for re-runs)
          if gh release view "$TAG_NAME" --repo "$ALTSTORE_REPO" >/dev/null 2>&1; then
            echo "üóëÔ∏è  Deleting existing release..."
            gh release delete "$TAG_NAME" --repo "$ALTSTORE_REPO" --yes
          fi

          # Create release on my-altstore repo and upload IPA
          gh release create "$TAG_NAME" \
            --repo "$ALTSTORE_REPO" \
            --title "EduLift $FLAVOR ${{ needs.prepare-release.outputs.version }}" \
            --notes "EduLift Mobile $FLAVOR build

          **Version:** ${{ needs.prepare-release.outputs.version }}
          **Build:** ${{ github.run_number }}
          **Commit:** ${{ github.sha }}

          This release contains the IPA file for AltStore PAL distribution." \
            "$IPA_PATH"

          echo "‚úÖ Release created on $ALTSTORE_REPO"

          # Get download URL for JSON
          IPA_DOWNLOAD_URL="https://github.com/$ALTSTORE_REPO/releases/download/$TAG_NAME/edulift-$FLAVOR.ipa"
          echo "ipa_download_url=$IPA_DOWNLOAD_URL" >> $GITHUB_OUTPUT
          echo "LINK:  IPA Download URL: $IPA_DOWNLOAD_URL"

      - name: Update AltStore PAL source
        env:
          GH_TOKEN: ${{ secrets.MY_ALTSTORE_TOKEN }}
        run: |
          set -e

          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          VERSION="${{ needs.prepare-release.outputs.version }}"
          IPA_PATH="release-files/edulift-$FLAVOR.ipa"
          DOWNLOAD_URL="${{ steps.altstore_release.outputs.ipa_download_url }}"
          IPA_SIZE=$(stat -c%s "$IPA_PATH")

          echo "üì± Updating AltStore PAL source..."
          echo "   Flavor: $FLAVOR"
          echo "   Version: $VERSION"
          echo "   Download URL: $DOWNLOAD_URL"
          echo "   IPA Size: $IPA_SIZE bytes"

          # Clone AltStore repo
          ALTSTORE_REPO="jrevillard/my-altstore"
          ALTSTORE_BRANCH="main"

          mkdir -p altstore_temp
          cd altstore_temp

          echo "üì¶ Cloning $ALTSTORE_REPO..."
          gh repo clone $ALTSTORE_REPO .
          git checkout $ALTSTORE_BRANCH

          # Configure git for commits
          git config user.name "GitHub Actions"
          git config user.email "action@github.com"

          # Configure git to use the GitHub token for authentication
          git config credential.helper store
          echo "https://x-access-token:${GH_TOKEN}@github.com" > ~/.git-credentials

          # Run the update script from my-altstore repo
          echo "üöÄ Running update-altstore.sh script..."
          chmod +x scripts/update-altstore.sh

          ./scripts/update-altstore.sh \
            "edulift" \
            "$FLAVOR" \
            "$DOWNLOAD_URL" \
            "$VERSION" \
            "$IPA_SIZE"

          # Commit and push changes
          if git diff --quiet && git diff --staged --quiet; then
            echo "‚ÑπÔ∏è  No changes to commit"
          else
            git add -A
            git commit -m "feat: update EduLift $FLAVOR to version $VERSION"
            git push origin $ALTSTORE_BRANCH
            echo "‚úÖ AltStore PAL source updated successfully"
          fi

          cd ..
          rm -rf altstore_temp

          echo "üéâ AltStore update completed!"
          echo "üìã View changes: https://github.com/$ALTSTORE_REPO/commits/$ALTSTORE_BRANCH"

      - name: Release summary
        run: |
          echo "üéâ Unified release completed!"
          echo ""
          echo "INFO:  Release Details:"
          echo "   Tag: ${{ needs.prepare-release.outputs.tag_name }}"
          echo "   Version: ${{ needs.prepare-release.outputs.version }}"
          echo "   Environment: ${{ needs.prepare-release.outputs.flavor }}"
          echo "   Platforms: iOS + Android"
          echo "   AltStore: SUCCESS: Updated"
          echo ""
          echo "LINK:  View release: https://github.com/${{ github.repository }}/releases/tag/${{ needs.prepare-release.outputs.tag_name }}"

      - name: Reset pubspec.yaml for development
        if: success()  # Only run if all previous steps succeeded
        run: |
          set -e
          echo "üîÑ Resetting pubspec.yaml for development after successful release..."

          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          TARGET_BRANCH="main"

          echo "üîÑ Fetching target branch '$TARGET_BRANCH'..."
          git fetch origin $TARGET_BRANCH

          echo "INFO:  Checking out '$TARGET_BRANCH'..."
          git checkout $TARGET_BRANCH

          echo "üîÑ Resetting local branch to match remote..."
          git reset --hard origin/$TARGET_BRANCH

          # Reset pubspec.yaml to development version after successful release
          BASE_VERSION="${{ needs.prepare-release.outputs.base_version }}"

          # Calculate next patch version for development
          # Example: 0.1.0 ‚Üí 0.1.1-dev+1
          NEXT_PATCH=$(echo "$BASE_VERSION" | awk -F. '{print $1"."$2"."($3+1)}')
          DEV_VERSION="${NEXT_PATCH}-dev+1"

          sed -i "s/^version: .*/version: $DEV_VERSION/" pubspec.yaml
          echo "üî¢ Development version calculated: $DEV_VERSION (from $BASE_VERSION)"

          # Commit the development version reset
          git add pubspec.yaml
          git commit -m " [skip ci] chore: reset pubspec.yaml to development version $DEV_VERSION"
          git push origin $TARGET_BRANCH

          echo "SUCCESS:  Successfully reset pubspec.yaml to development version: $DEV_VERSION"
          echo "üöÄ Ready for next development cycle!"

  # Job 5: Handle build failures (notification)
  handle-failures:
    name: Handle Build Failures
    runs-on: ubuntu-latest
    needs: [prepare-release, build-ios, build-android]
    if: always() && (needs.build-ios.result == 'failure' || needs.build-android.result == 'failure')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Notify build failures
        run: |
          echo "ERROR:  Build failures detected!"
          echo ""
          echo "INFO:  Build Status Summary:"
          echo "   Prepare Release: ${{ needs.prepare-release.result }}"
          echo "   Build iOS: ${{ needs.build-ios.result }}"
          echo "   Build Android: ${{ needs.build-android.result }}"
          echo ""

          if [[ "${{ needs.build-ios.result }}" == "failure" ]]; then
            echo " iOS build failed - check Codemagic logs"
          fi

          if [[ "${{ needs.build-android.result }}" == "failure" ]]; then
            echo " Android build failed - check GitHub Actions logs"
          fi

          echo "LINK:  Monitor builds:"
          echo "   GitHub Actions: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          if [[ -n "${{ vars.CODEMAGIC_APP_ID }}" ]]; then
            echo "   Codemagic: https://codemagic.io/app/${{ vars.CODEMAGIC_APP_ID }}/builds"
          fi
