# .github/workflows/cd.yml - Mobile Unified Release System
#
# OVERVIEW:
# =========
# This workflow implements a unified release system that coordinates iOS builds (via Codemagic)
# and Android builds (via GitHub Actions) using a branch-based approach.
#
# TRIGGER:
# =======
# - push to branches matching pattern: 'release/*'
# - Validates semantic version format (e.g., 2.1.0, 2.1.0-beta2, 2.1.0-rc1)
# - Rejects invalid branch names (test, fix, hotfix, experimental, wip, temp)
#
# WORKFLOW FLOW:
# ===============
# 1. prepare-release: Extract version, update pubspec.yaml, create git tag, merge to main
# 2. build-ios: Trigger Codemagic build, wait completion, download artifacts
# 3. build-android: Build APK/AAB in parallel
# 4. create-unified-release: Create GitHub release, update AltStore PAL source
# 5. handle-failures: Notify on build failures
#
# SECURITY:
# ==========
# - Semantic version regex validation prevents unauthorized releases
# - All secrets properly stored in GitHub Actions secrets
# - No hardcoded credentials in any scripts or configurations
# - Fail-fast on any validation errors
#
# ARCHITECTURE:
# ============
# - GitHub Actions: Central coordinator and version management
# - Codemagic: Build-only iOS execution (no version management conflicts)
# - AltStore PAL: Automatic source updates for iOS distribution
# - Firebase: App Distribution integration for testing
#
name: Mobile Unified Release

permissions:
  contents: write
  pull-requests: write

on:
  push:
    branches:
      - 'release/*'

env:
  # Flutter configuration
  FLUTTER_VERSION: ${{ vars.FLUTTER_VERSION || '3.38.2' }}
  JAVA_VERSION: ${{ vars.JAVA_VERSION || '17' }}

jobs:
  # Job 1: Prepare release environment
  prepare-release:
    name: Prepare Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      flavor: ${{ steps.version.outputs.flavor }}
      tag_name: ${{ steps.version.outputs.tag_name }}
      is_staging: ${{ steps.version.outputs.is_staging }}
      base_version: ${{ steps.version.outputs.base_version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Load CI/CD versions
        id: load-versions
        run: |
          if [[ -f ".github/ci-versions.env" ]]; then
            while IFS='=' read -r key value; do
              # Skip empty lines and comments
              if [[ -n "$key" && ! "$key" =~ ^[[:space:]]*# ]]; then
                echo "$key=$value" >> $GITHUB_OUTPUT
              fi
            done < .github/ci-versions.env
          fi

      - name: Validate version format
        id: validate-version
        run: |
          BRANCH_NAME="${GITHUB_REF_NAME}"
          echo "Processing release branch: $BRANCH_NAME"

          # Extract version from branch name (remove 'release/' prefix)
          VERSION="${BRANCH_NAME#release/}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

          # Validate semantic version format
          # Patterns:
          # - 2.1.0 (production)
          # - 2.1.0-alpha1, 2.1.0-beta2, 2.1.0-rc1 (staging)
          if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-((alpha|beta|rc)[0-9]*))?$ ]]; then
            echo "ERROR:  Invalid version format: $VERSION"
            echo ""
            echo "Expected formats:"
            echo "  - 2.1.0 (production)"
            echo "  - 2.1.0-alpha1 (staging)"
            echo "  - 2.1.0-beta2 (staging)"
            echo "  - 2.1.0-rc1 (staging)"
            echo ""
            echo "Rejected: test, fix, hotfix, bugfix, experimental, wip, temp, etc."
            echo ""
            echo "Please use semantic versioning format in release/ branches."
            exit 1
          fi

          # Extract base version (remove pre-release)
          BASE_VERSION=$(echo "$VERSION" | sed -E 's/(-alpha|-beta|-rc).*//')
          echo "base_version=$BASE_VERSION" >> $GITHUB_OUTPUT

          # Create tag name for later use
          TAG_NAME="v$VERSION"
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

          # Determine flavor from version pattern
          if [[ "$VERSION" =~ (alpha|beta|rc) ]]; then
            FLAVOR="staging"
            IS_STAGING="true"
          else
            FLAVOR="production"
            IS_STAGING="false"
          fi

          echo "flavor=$FLAVOR" >> $GITHUB_OUTPUT
          echo "is_staging=$IS_STAGING" >> $GITHUB_OUTPUT

          echo "SUCCESS:  Version format validated: $VERSION"
          echo "INFO:  Release Info:"
          echo "   Branch: $BRANCH_NAME"
          echo "   Version: $VERSION"
          echo "   Tag: $TAG_NAME"
          echo "   Base Version: $BASE_VERSION"
          echo "   Flavor: $FLAVOR"
          echo "   Staging: $IS_STAGING"

      - name: Extract version and flavor from branch
        id: version
        run: |
          # This step now just passes through the validated values
          echo "version=${{ steps.validate-version.outputs.version }}" >> $GITHUB_OUTPUT
          echo "base_version=${{ steps.validate-version.outputs.base_version }}" >> $GITHUB_OUTPUT
          echo "tag_name=${{ steps.validate-version.outputs.tag_name }}" >> $GITHUB_OUTPUT
          echo "flavor=${{ steps.validate-version.outputs.flavor }}" >> $GITHUB_OUTPUT
          echo "is_staging=${{ steps.validate-version.outputs.is_staging }}" >> $GITHUB_OUTPUT

      - name: Check if release already exists
        id: check-release
        run: |
          TAG_NAME="${{ steps.version.outputs.tag_name }}"
          VERSION="${{ steps.version.outputs.version }}"
          BRANCH_NAME="${GITHUB_REF_NAME}"

          echo " Checking if release $TAG_NAME already exists..."

          # Check if tag already exists
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "ERROR:  Release $TAG_NAME already exists!"
            echo "ðŸš« This version has already been released."
            echo ""
            echo "INFO:  To rebuild this release:"
            echo "   git tag -d $TAG_NAME"
            echo "   git push origin --delete $TAG_NAME"
            echo "   Then re-run the workflow"
            echo ""
            echo "ðŸŽ¯ Skipping build to avoid duplicate release"
            exit 1
          fi

      - name: Update pubspec.yaml
        run: |
          # Use run number as build number
          BUILD_NUMBER="${{ github.run_number }}"
          BASE_VERSION="${{ steps.version.outputs.base_version }}"

          sed -i "s/^version: .*/version: $BASE_VERSION+$BUILD_NUMBER/" pubspec.yaml

          echo "SUCCESS:  Updated pubspec.yaml:"
          grep "^version:" pubspec.yaml

      - name: Commit version update
        run: |
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Add and commit version update
          git add pubspec.yaml
          git commit -m "[skip ci] chore: update version to ${{ steps.version.outputs.base_version }}+${{ github.run_number }}"

          # Push commit to release branch (force-with-lease for safety)
          git push origin release/${{ steps.version.outputs.version }} --force-with-lease

          echo "SUCCESS:  Committed version update to release/${{ steps.version.outputs.version }}"

      - name: Merge to main and create tag
        run: |
          set -e

          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          TARGET_BRANCH="main"
          RELEASE_BRANCH="release/${{ steps.version.outputs.version }}"
          TAG_NAME="${{ steps.version.outputs.tag_name }}"

          echo "ðŸ”„ Fetching target branch..."
          git fetch origin $TARGET_BRANCH

          echo "INFO:  Checking out '$TARGET_BRANCH'..."
          git checkout $TARGET_BRANCH

          echo "ðŸ”€ Merging '$RELEASE_BRANCH' into '$TARGET_BRANCH'..."
          git merge origin/$RELEASE_BRANCH --no-ff -m "[skip ci] chore(release): Release ${{ steps.version.outputs.version }}"

          echo "ðŸ“¤ Pushing merge to '$TARGET_BRANCH'..."
          git push origin $TARGET_BRANCH

          echo "ðŸ·ï¸ Creating tag '$TAG_NAME' on '$TARGET_BRANCH'..."
          git tag -a "$TAG_NAME" -m "Release ${{ steps.version.outputs.version }}"
          git push origin "$TAG_NAME"

          echo "ðŸ§¹ Cleaning up release branch '$RELEASE_BRANCH'..."
          git push origin --delete "$RELEASE_BRANCH"

          echo "SUCCESS:  Successfully merged $RELEASE_BRANCH to $TARGET_BRANCH"
          echo "SUCCESS:  Created and pushed tag: $TAG_NAME"
          echo "SUCCESS:  Deleted release branch: $RELEASE_BRANCH"

  # Job 2: Build iOS (trigger Codemagic)
  build-ios:
    name: Build iOS
    runs-on: ubuntu-latest
    needs: prepare-release
    outputs:
      final_build_info: ${{ steps.wait-ios.outputs.build_info }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Trigger Codemagic iOS build
        id: trigger-ios
        env:
          CODEMAGIC_API_TOKEN: ${{ secrets.CODEMAGIC_API_TOKEN }}
        run: |
          # Map flavor to workflow ID
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          if [[ "$FLAVOR" == "staging" ]]; then
            WORKFLOW_ID="ios-staging"
          elif [[ "$FLAVOR" == "production" ]]; then
            WORKFLOW_ID="ios-production"
          else
            echo "ERROR:  Unknown flavor: $FLAVOR"
            exit 1
          fi

          ./scripts/trigger-codemagic-api.sh \
            "${{ vars.CODEMAGIC_APP_ID }}" \
            "$WORKFLOW_ID" \
            "main" \
            "${{ needs.prepare-release.outputs.tag_name }}"

      - name: Wait for iOS build completion
        id: wait-ios
        env:
          CODEMAGIC_API_TOKEN: ${{ secrets.CODEMAGIC_API_TOKEN }}
        run: |
          ./scripts/wait-codemagic-build.sh \
            "${{ steps.trigger-ios.outputs.BUILD_ID }}" \
            "1800" "30"  # 30 minutes max, 30 second polling

      - name: Validate build info availability
        env:
          BUILD_INFO: ${{ steps.wait-ios.outputs.build_info }}
        run: |
          echo "Checking build info availability..."

          # Verify build_info is available and valid
          if [[ -z "$BUILD_INFO" ]]; then
            echo "ERROR:  Build info not available - build polling may have failed"
            echo "INFO:  This usually means the wait-codemagic-build.sh script did not complete properly"
            echo "LINK:  Check the previous step logs for build polling errors"
            exit 1
          fi

          # Validate build info JSON format using safer approach
          if ! printf '%s\n' "$BUILD_INFO" | jq -e '.build.artefacts' >/dev/null 2>&1; then
            echo "ERROR:  Invalid build info JSON format - build polling may have failed"
            echo "DATA:  Build info content (first 500 chars):"
            printf '%s\n' "$BUILD_INFO" | head -c 500
            echo ""
            echo "INFO:  The build info should be valid JSON with 'build.artefacts' array"
            exit 1
          fi

          echo "SUCCESS:  Build info validated successfully"
          echo "DATA:  Build status: $(printf '%s\n' "$BUILD_INFO" | jq -r '.build.status')"
          echo "FILES:  Artifact count: $(printf '%s\n' "$BUILD_INFO" | jq -r '.build.artefacts | length')"

  # Job 3: Build Android (parallel)
  build-android:
    name: Build Android
    runs-on: ubuntu-latest
    needs: prepare-release

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Load CI/CD versions
        id: load-versions
        run: |
          if [[ -f ".github/ci-versions.env" ]]; then
            while IFS='=' read -r key value; do
              # Skip empty lines and comments
              if [[ -n "$key" && ! "$key" =~ ^[[:space:]]*# ]]; then
                echo "$key=$value" >> $GITHUB_OUTPUT
              fi
            done < .github/ci-versions.env
          fi

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ steps.load-versions.outputs.FLUTTER_VERSION }}
          channel: ${{ steps.load-versions.outputs.FLUTTER_CHANNEL }}
          cache: true

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ steps.load-versions.outputs.JAVA_VERSION }}

      - name: Cache Flutter dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.pub-cache
            .dart_tool
          key: v1-${{ runner.os }}-flutter-${{ steps.load-versions.outputs.FLUTTER_VERSION }}-${{ hashFiles('**/pubspec.lock') }}
          restore-keys: |
            v1-${{ runner.os }}-flutter-${{ steps.load-versions.outputs.FLUTTER_VERSION }}-

      - name: Cache Android Gradle dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
            android/.gradle
          key: v1-${{ runner.os }}-gradle-${{ hashFiles('**/gradle-wrapper.properties') }}-${{ hashFiles('**/*.gradle*', '**/libs.versions.toml', '**/gradle/libs.versions.toml') }}
          restore-keys: |
            v1-${{ runner.os }}-gradle-${{ hashFiles('**/gradle-wrapper.properties') }}-

      - name: Build Android
        run: |
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          echo "BUILD:  Building Android $FLAVOR..."

          if [[ "${{ needs.prepare-release.outputs.is_staging }}" == "true" ]]; then
            echo "ANDROID:  Building APK for staging"
            flutter build apk --release \
              --flavor $FLAVOR \
              --dart-define-from-file=config/$FLAVOR.json \
              --split-debug-info=build/debug-info \
              --obfuscate \
              --no-shrink \
              --tree-shake-icons
          else
            echo "FILES:  Building AAB for production"
            flutter build appbundle --release \
              --flavor $FLAVOR \
              --dart-define-from-file=config/$FLAVOR.json \
              --split-debug-info=build/debug-info \
              --obfuscate \
              --no-shrink \
              --tree-shake-icons
          fi

          echo "INFO:  Build artifacts generated:"
          echo "   Flutter debug symbols: build/debug-info/"
          echo "   Mapping files: build/debug-info/*.map"
          echo "   APK/AAB: build/app/outputs/"

      - name: Setup Firebase CLI (Staging)
        if: needs.prepare-release.outputs.flavor == 'staging'
        uses: w9jds/setup-firebase@main
        with:
          gcp_sa_key: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_STAGING }}

      - name: Setup Firebase CLI (Production)
        if: needs.prepare-release.outputs.flavor == 'production'
        uses: w9jds/setup-firebase@main
        with:
          gcp_sa_key: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_PROD }}

      - name: Upload symbols to Firebase Crashlytics
        run: |
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          echo " Uploading debug symbols to Firebase Crashlytics for $FLAVOR..."

          # Determine Firebase App ID based on flavor
          if [[ "$FLAVOR" == "staging" ]]; then
            FIREBASE_APP_ID="${{ steps.load-versions.outputs.FIREBASE_ANDROID_STAGING_APP_ID }}"
          else
            FIREBASE_APP_ID="${{ steps.load-versions.outputs.FIREBASE_ANDROID_PROD_APP_ID }}"
          fi

          # Check if debug symbols exist before uploading
          if [[ -d "build/debug-info" ]] && [[ "$(ls -A build/debug-info 2>/dev/null)" ]]; then
            echo "INFO:  Uploading debug symbols with obfuscation mappings to Firebase Crashlytics..."
            echo "INFO:  Debug symbols directory contents:"
            ls -lh build/debug-info/

            # Upload all .symbols files - these contain BOTH debug info AND obfuscation mappings
            # Flutter generates .symbols files (NOT .map files) that include embedded obfuscation data
            if firebase crashlytics:symbols:upload --app="$FIREBASE_APP_ID" build/debug-info/; then
              echo "SUCCESS:  Debug symbols uploaded (includes obfuscation mappings)"

              # Verify upload with Firebase CLI
              echo "INFO:  Verifying symbol upload..."
              firebase crashlytics:mappingfile:list --app="$FIREBASE_APP_ID" | tail -5 || echo "INFO:  Verification skipped (CLI limitation)"
            else
              echo "ERROR:  Symbol upload failed!"
              echo "IMPACT: Production crashes cannot be de-obfuscated!"
              exit 1
            fi

            # Check for native symbols (if using NDK or native plugins)
            NATIVE_LIBS_DIR="build/app/intermediates/merged_native_libs/${FLAVOR}/release/out/lib"
            if [[ -d "$NATIVE_LIBS_DIR" ]] && [[ "$(find "$NATIVE_LIBS_DIR" -name "*.so" 2>/dev/null)" ]]; then
              echo "INFO:  Found native symbols, uploading from: $NATIVE_LIBS_DIR"
              firebase crashlytics:symbols:upload --app="$FIREBASE_APP_ID" "$NATIVE_LIBS_DIR" || echo "WARNING:  Native symbol upload failed (non-critical if no NDK plugins)"
            else
              echo "INFO:  No native symbols found (this is normal if not using NDK plugins)"
            fi

            echo "SUCCESS:  Crashlytics symbol upload completed"
            echo "INFO:  Production crashes can now be properly analyzed and de-obfuscated"
          else
            echo "ERROR:  No debug symbols found - crash analysis will be impossible!"
            echo "PATH:   build/debug-info contents:"
            ls -la build/debug-info 2>/dev/null || echo "         Directory does not exist"
            exit 1
          fi

  
      - name: Distribute to Firebase
        run: |
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          VERSION="${{ needs.prepare-release.outputs.version }}"
          TAG_NAME="${{ needs.prepare-release.outputs.tag_name }}"

          if [[ "$FLAVOR" == "staging" ]]; then
            APK_PATH="build/app/outputs/flutter-apk/app-staging-release.apk"

            firebase appdistribution:distribute "$APK_PATH" \
              --app "${{ steps.load-versions.outputs.FIREBASE_ANDROID_STAGING_APP_ID }}" \
              --groups "${{ secrets.FIREBASE_GROUPS_STAGING || 'internal-testers' }}" \
              --release-notes "Pre-release $TAG_NAME from commit ${{ github.sha }}"
          else
            AAB_PATH="build/app/outputs/bundle/release/app-production-release.aab"

            firebase appdistribution:distribute "$AAB_PATH" \
              --app "${{ steps.load-versions.outputs.FIREBASE_ANDROID_PROD_APP_ID }}" \
              --groups "${{ secrets.FIREBASE_GROUPS_PROD || 'production-testers' }}" \
              --release-notes "Production release $TAG_NAME from commit ${{ github.sha }}"
          fi

  # Job 4: Create unified release
  create-unified-release:
    name: Create Unified Release
    runs-on: ubuntu-latest
    needs: [prepare-release, build-ios, build-android]
    if: always() && needs.build-ios.result == 'success' && needs.build-android.result == 'success'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Load CI/CD versions
        id: load-versions
        run: |
          if [[ -f ".github/ci-versions.env" ]]; then
            while IFS='=' read -r key value; do
              # Skip empty lines and comments
              if [[ -n "$key" && ! "$key" =~ ^[[:space:]]*# ]]; then
                echo "$key=$value" >> $GITHUB_OUTPUT
              fi
            done < .github/ci-versions.env
          fi

      - name: Setup Firebase CLI (Staging)
        if: needs.prepare-release.outputs.flavor == 'staging'
        uses: w9jds/setup-firebase@main
        with:
          gcp_sa_key: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_STAGING }}

      - name: Setup Firebase CLI (Production)
        if: needs.prepare-release.outputs.flavor == 'production'
        uses: w9jds/setup-firebase@main
        with:
          gcp_sa_key: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_PROD }}

      - name: Download Android artifacts from Firebase
        run: |
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          VERSION="${{ needs.prepare-release.outputs.version }}"
          TAG_NAME="${{ needs.prepare-release.outputs.tag_name }}"

          echo "ðŸ“± Downloading Android artifacts from Firebase App Distribution..."
          mkdir -p build/app/outputs/{flutter-apk,bundle/release}

          # RÃ©cupÃ©rer l'App ID Firebase en fonction du flavor
          if [[ "$FLAVOR" == "staging" ]]; then
            FIREBASE_APP_ID="${{ steps.load-versions.outputs.FIREBASE_ANDROID_STAGING_APP_ID }}"
            EXPECTED_FILE="app-staging-release.apk"
            TARGET_PATH="build/app/outputs/flutter-apk/app-staging-release.apk"
          else
            FIREBASE_APP_ID="${{ steps.load-versions.outputs.FIREBASE_ANDROID_PROD_APP_ID }}"
            EXPECTED_FILE="app-production-release.aab"
            TARGET_PATH="build/app/outputs/bundle/release/app-production-release.aab"
          fi

          echo "INFO:  Looking for app: $FIREBASE_APP_ID"
          echo "INFO:  Expected file: $EXPECTED_FILE"

          # Attendre plus longtemps que Firebase traite l'upload avec tentatives progressives
          echo "INFO:  Waiting for Firebase to process the upload..."
          for i in {1..5}; do
            echo "INFO:  Attempt $i/5 - Waiting 30s for Firebase processing..."
            sleep 30

            # RÃ©cupÃ©rer la liste des releases et tÃ©lÃ©charger la plus rÃ©cente
            RELEASE_INFO=$(firebase appdistribution:distribute list --app="$FIREBASE_APP_ID" --format=json 2>/dev/null)

            if [[ $? -eq 0 && -n "$RELEASE_INFO" ]]; then
              # Extraire l'URL de tÃ©lÃ©chargement de la release la plus rÃ©cente
              DOWNLOAD_URL=$(echo "$RELEASE_INFO" | jq -r '.releases[0].downloadUrl')
              RELEASE_VERSION=$(echo "$RELEASE_INFO" | jq -r '.releases[0].version')

              if [[ -n "$DOWNLOAD_URL" && "$DOWNLOAD_URL" != "null" ]]; then
                echo "SUCCESS: Found release $RELEASE_VERSION"
                echo "INFO:  Downloading from: $DOWNLOAD_URL"

                # TÃ©lÃ©charger le fichier avec timeout augmentÃ© et plus de tentatives
                wget -O "$TARGET_PATH" "$DOWNLOAD_URL" --timeout=600 --tries=5 --wait=10 || {
                  echo "ERROR: Failed to download from Firebase"
                  echo "INFO:  Continuing to next attempt..."
                  continue
                }

                # VÃ©rifier que le fichier a Ã©tÃ© tÃ©lÃ©chargÃ©
                if [[ -f "$TARGET_PATH" && -s "$TARGET_PATH" ]]; then
                  FILE_SIZE=$(stat -c%s "$TARGET_PATH")
                  echo "SUCCESS: Downloaded $(basename $TARGET_PATH) ($FILE_SIZE bytes)"
                  break  # Sortir de la boucle for
                else
                  echo "WARNING: Downloaded file is empty or missing, retrying..."
                  continue
                fi
              else
                echo "WARNING: No download URL found in latest release, retrying..."
                continue
              fi
            else
              echo "WARNING: Failed to get releases from Firebase App Distribution (attempt $i/5)"
              if [[ $i -eq 5 ]]; then
                echo "ERROR: All attempts failed"
                echo "INFO:  Make sure the app was uploaded successfully in build-android job"
                echo "INFO:  Check Firebase App Distribution for upload status"
                exit 1
              fi
            fi
          done

      - name: Prepare release files
        env:
          BUILD_INFO: ${{ needs.build-ios.outputs.final_build_info }}
        run: |
          VERSION="${{ needs.prepare-release.outputs.version }}"
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          TAG_NAME="${{ needs.prepare-release.outputs.tag_name }}"
          mkdir -p release-files

          # iOS: Utiliser le script Codemagic existant pour tÃ©lÃ©charger l'IPA
          ./scripts/download-codemagic-artifacts.sh "$BUILD_INFO" "ios-artifacts-temp"
          IOS_IPA=$(find ios-artifacts-temp -name "*.ipa" | head -1)
          if [[ -n "$IOS_IPA" ]]; then
            cp "$IOS_IPA" "release-files/edulift-$FLAVOR.ipa"
            echo "SUCCESS:  iOS IPA: $(basename $IOS_IPA)"
          else
            echo "ERROR:  No iOS IPA found"
            exit 1
          fi

          # Android: Fichiers tÃ©lÃ©chargÃ©s depuis les artifacts du job build-android
          if [[ "$FLAVOR" == "staging" ]]; then
            ANDROID_FILE="build/app/outputs/flutter-apk/app-staging-release.apk"
            TARGET_FILE="edulift-$FLAVOR.apk"
          else
            ANDROID_FILE="build/app/outputs/bundle/release/app-production-release.aab"
            TARGET_FILE="edulift-$FLAVOR.aab"
          fi

          # Verify artifact was downloaded correctly
          if [[ -f "$ANDROID_FILE" ]]; then
            FILE_SIZE=$(stat -c%s "$ANDROID_FILE")
            echo "SUCCESS:  Android artifact found: $(basename $ANDROID_FILE) ($FILE_SIZE bytes)"

            # Validate minimum file size (10MB)
            if [[ $FILE_SIZE -lt 10485760 ]]; then
              echo "WARNING:  Artifact seems unusually small (< 10MB) - may be corrupted"
            fi

            cp "$ANDROID_FILE" "release-files/$TARGET_FILE"
          else
            echo "ERROR:  No Android file found: $ANDROID_FILE"
            echo "Available files in build/app/outputs:"
            find build/app/outputs -type f -name "*.apk" -o -name "*.aab" 2>/dev/null || echo "No APK/AAB files found"
            exit 1
          fi

          echo "FILES:  Final release files:"
          ls -la release-files/

      - name: Create unified GitHub release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.prepare-release.outputs.tag_name }}
          name: EduLift Mobile ${{ needs.prepare-release.outputs.flavor }} ${{ needs.prepare-release.outputs.version }}
          body: |
            EduLift Mobile ${{ needs.prepare-release.outputs.flavor }} release

            **Version:** ${{ needs.prepare-release.outputs.version }}
            **Platform:** iOS + Android (Unified)
            **Environment:** ${{ needs.prepare-release.outputs.flavor }}
            **Commit:** ${{ github.sha }}
            **Build:** ${{ github.run_number }}

            ## ðŸ“± Downloads

            **iOS (AltStore PAL):**
            - ðŸ“¦ `edulift-${{ needs.prepare-release.outputs.flavor }}.ipa`
            - Unsigned build for AltStore PAL distribution

            **Android:**
            ${{ needs.prepare-release.outputs.is_staging == 'true' && '- ðŸ“¦ `edulift-staging.apk`\n- For Firebase App Distribution testing' || '- ðŸ“¦ `edulift-production.aab`\n- For Google Play Store release' }}

            ## ðŸ”— Links

            - **Download:** Click assets below â¬‡ï¸
            - **Commit:** [${{ github.sha }}](https://github.com/${{ github.repository }}/commit/${{ github.sha }})
            ${{ needs.prepare-release.outputs.is_staging == 'true' && '- **Testing:** Firebase App Distribution' || '- **Store:** Google Play Console' }}

          files: release-files/*
          draft: false
          prerelease: ${{ needs.prepare-release.outputs.is_staging }}
          generate_release_notes: true

      - name: Get download URL for AltStore
        id: urls
        run: |
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          TAG_NAME="${{ needs.prepare-release.outputs.tag_name }}"

          IPA_DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/$TAG_NAME/edulift-$FLAVOR.ipa"

          echo "ipa_download_url=$IPA_DOWNLOAD_URL" >> $GITHUB_OUTPUT
          echo "LINK:  IPA Download URL: $IPA_DOWNLOAD_URL"

      - name: Update AltStore PAL source
        run: |
          FLAVOR="${{ needs.prepare-release.outputs.flavor }}"
          IPA_PATH="release-files/edulift-$FLAVOR.ipa"
          DOWNLOAD_URL="${{ steps.urls.outputs.ipa_download_url }}"

          echo "ANDROID:  Updating AltStore PAL source..."
          echo "   Flavor: $FLAVOR"
          echo "   IPA: $IPA_PATH"
          echo "   Download URL: $DOWNLOAD_URL"

          # Setup git for AltStore repo updates
          ALTSTORE_REPO="jrevillard/my-altstore"
          ALTSTORE_BRANCH="main"

          mkdir -p altstore_temp
          cd altstore_temp

          # Configure git with GitHub CLI for proper authentication
          # GitHub CLI uses GITHUB_TOKEN automatically with correct permissions
          if command -v gh &> /dev/null; then
            echo "INFO:  Using GitHub CLI for authenticated clone..."
            gh repo clone $ALTSTORE_REPO .
          else
            echo "INFO:  GitHub CLI not available, using git with token..."
            # Fallback to git clone with token (requires GITHUB_TOKEN with repo scope)
            git clone https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/$ALTSTORE_REPO.git .
          fi

          git checkout $ALTSTORE_BRANCH

          # Configure git for commits
          git config user.name "GitHub Actions"
          git config user.email "action@github.com"

          # Get app info from pre-extracted version
          VERSION="${{ needs.prepare-release.outputs.version }}"
          BUILD_NUMBER="${{ github.run_number }}"
          IPA_SIZE=$(du -h "../$IPA_PATH" | cut -f1)

          # Generate AltStore PAL JSON
          mkdir -p apps
          APP_JSON="apps/${FLAVOR}.json"

          # Use jq to generate JSON safely
          jq -n \
            --arg name "EduLift" \
            --arg bundleId "com.edulift.app${FLAVOR:+:.staging}" \
            --arg version "$VERSION" \
            --arg versionDate "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --arg localizedDescription "Version $VERSION - Build $BUILD_NUMBER" \
            --arg downloadURL "$DOWNLOAD_URL" \
            --arg size "$IPA_SIZE" \
            --arg iconURL "https://raw.githubusercontent.com/jrevillard/edulift-mobile/main/docs/edulift-icon.png" \
            --arg tintColor "#1976d2" \
            '{
              "name": $name,
              "bundleIdentifier": $bundleId,
              "version": $version,
              "versionDate": $versionDate,
              "localizedDescription": $localizedDescription,
              "downloadURL": $downloadURL,
              "size": ($size | tonumber),
              "iconURL": $iconURL,
              "tintColor": $tintColor
            }' > "$APP_JSON"

          echo "SUCCESS:  Generated $APP_JSON:"
          echo "   Name: EduLift $FLAVOR"
          echo "   Bundle ID: com.edulift.app${FLAVOR:+:.staging}"
          echo "   Download URL: $DOWNLOAD_URL"
          echo "   Size: $IPA_SIZE"

          # Commit and push changes
          if git diff --quiet; then
            echo "INFO:  No changes to AltStore source (version already up to date)"
          else
            git add .
            git commit -m "feat: update EduLift $FLAVOR to version $VERSION"

            # Push with retry logic (handles race conditions)
            MAX_RETRIES=3
            for i in $(seq 1 $MAX_RETRIES); do
              if git push origin $ALTSTORE_BRANCH; then
                echo "SUCCESS:  AltStore PAL source updated successfully"
                break
              elif [[ $i -lt $MAX_RETRIES ]]; then
                echo "WARNING:  Push failed (attempt $i/$MAX_RETRIES), retrying..."
                git pull --rebase origin $ALTSTORE_BRANCH
                sleep 2
              else
                echo "ERROR:  Failed to push AltStore updates after $MAX_RETRIES attempts"
                exit 1
              fi
            done
          fi

          cd ..
          rm -rf altstore_temp

      - name: Release summary
        run: |
          echo "ðŸŽ‰ Unified release completed!"
          echo ""
          echo "INFO:  Release Details:"
          echo "   Tag: ${{ needs.prepare-release.outputs.tag_name }}"
          echo "   Version: ${{ needs.prepare-release.outputs.version }}"
          echo "   Environment: ${{ needs.prepare-release.outputs.flavor }}"
          echo "   Platforms: iOS + Android"
          echo "   AltStore: SUCCESS: Updated"
          echo ""
          echo "LINK:  View release: https://github.com/${{ github.repository }}/releases/tag/${{ needs.prepare-release.outputs.tag_name }}"

      - name: Reset pubspec.yaml for development
        if: success()  # Only run if all previous steps succeeded
        run: |
          set -e
          echo "ðŸ”„ Resetting pubspec.yaml for development after successful release..."

          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          TARGET_BRANCH="main"

          echo "ðŸ”„ Fetching target branch '$TARGET_BRANCH'..."
          git fetch origin $TARGET_BRANCH

          echo "INFO:  Checking out '$TARGET_BRANCH'..."
          git checkout $TARGET_BRANCH

          echo "ðŸ”„ Resetting local branch to match remote..."
          git reset --hard origin/$TARGET_BRANCH

          # Reset pubspec.yaml to development version after successful release
          BASE_VERSION="${{ needs.prepare-release.outputs.base_version }}"

          # Calculate next patch version for development
          # Example: 0.1.0 â†’ 0.1.1-dev+1
          NEXT_PATCH=$(echo "$BASE_VERSION" | awk -F. '{print $1"."$2"."($3+1)}')
          DEV_VERSION="${NEXT_PATCH}-dev+1"

          sed -i "s/^version: .*/version: $DEV_VERSION/" pubspec.yaml
          echo "ðŸ”¢ Development version calculated: $DEV_VERSION (from $BASE_VERSION)"

          # Commit the development version reset
          git add pubspec.yaml
          git commit -m " [skip ci] chore: reset pubspec.yaml to development version $DEV_VERSION"
          git push origin $TARGET_BRANCH

          echo "SUCCESS:  Successfully reset pubspec.yaml to development version: $DEV_VERSION"
          echo "ðŸš€ Ready for next development cycle!"

  # Job 5: Handle build failures (notification)
  handle-failures:
    name: Handle Build Failures
    runs-on: ubuntu-latest
    needs: [prepare-release, build-ios, build-android]
    if: always() && (needs.build-ios.result == 'failure' || needs.build-android.result == 'failure')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Notify build failures
        run: |
          echo "ERROR:  Build failures detected!"
          echo ""
          echo "INFO:  Build Status Summary:"
          echo "   Prepare Release: ${{ needs.prepare-release.result }}"
          echo "   Build iOS: ${{ needs.build-ios.result }}"
          echo "   Build Android: ${{ needs.build-android.result }}"
          echo ""

          if [[ "${{ needs.build-ios.result }}" == "failure" ]]; then
            echo " iOS build failed - check Codemagic logs"
          fi

          if [[ "${{ needs.build-android.result }}" == "failure" ]]; then
            echo " Android build failed - check GitHub Actions logs"
          fi

          echo "LINK:  Monitor builds:"
          echo "   GitHub Actions: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          if [[ -n "${{ vars.CODEMAGIC_APP_ID }}" ]]; then
            echo "   Codemagic: https://codemagic.io/app/${{ vars.CODEMAGIC_APP_ID }}/builds"
          fi
