# Flutter Testing Best Practices (2025)\n\nThis directory contains comprehensive testing infrastructure following Flutter 2025 best practices and TDD London School methodology.\n\n## ğŸ“ Directory Structure\n\n```\ntest/\nâ”œâ”€â”€ README.md                           # This file\nâ”œâ”€â”€ flutter_test_config.dart           # Global test configuration\nâ”‚\nâ”œâ”€â”€ support/                            # Testing infrastructure\nâ”‚   â”œâ”€â”€ test_environment.dart          # Test environment setup\nâ”‚   â”œâ”€â”€ test_builders.dart             # Test data builders\nâ”‚   â”œâ”€â”€ mock_factories.dart            # Mock creation and configuration\nâ”‚   â”œâ”€â”€ widget_test_base.dart           # Widget testing base class\nâ”‚   â”œâ”€â”€ integration_test_base.dart      # Integration testing base class\nâ”‚   â”œâ”€â”€ accessibility_test_helper.dart  # Accessibility testing utilities\nâ”‚   â”œâ”€â”€ golden_test_helper.dart         # Golden file testing utilities\nâ”‚   â””â”€â”€ test_coverage_config.dart       # Coverage analysis tools\nâ”‚\nâ”œâ”€â”€ examples/                           # Best practice examples\nâ”‚   â”œâ”€â”€ best_practices_unit_test_example.dart\nâ”‚   â”œâ”€â”€ best_practices_widget_test_example.dart\nâ”‚   â””â”€â”€ best_practices_integration_test_example.dart\nâ”‚\nâ”œâ”€â”€ unit/                              # Unit tests\nâ”‚   â”œâ”€â”€ core/                          # Core functionality tests\nâ”‚   â”œâ”€â”€ features/                      # Feature-specific unit tests\nâ”‚   â””â”€â”€ helpers/                       # Unit test helpers\nâ”‚\nâ”œâ”€â”€ widget/                            # Widget tests\nâ”‚   â”œâ”€â”€ features/                      # Feature widget tests\nâ”‚   â””â”€â”€ helpers/                       # Widget test helpers\nâ”‚\nâ”œâ”€â”€ integration/                       # Integration tests\nâ”‚   â””â”€â”€ [end-to-end test files]\nâ”‚\nâ”œâ”€â”€ fakes/                             # Test doubles and fakes\nâ”‚   â””â”€â”€ fake_secure_storage.dart\nâ”‚\nâ”œâ”€â”€ helpers/                           # Shared test utilities\nâ”‚   â””â”€â”€ test_di_initializer.dart\nâ”‚\nâ””â”€â”€ goldens/                           # Golden file test images\n    â”œâ”€â”€ accessibility/\n    â”œâ”€â”€ errors/\n    â””â”€â”€ loading/\n```\n\n## ğŸ¯ Testing Philosophy\n\nThis project follows **TDD London School** methodology with these principles:\n\n- **Test Types Separation**: Clear separation between unit, widget, and integration tests\n- **Mock-Heavy Approach**: Extensive use of mocks to isolate units under test\n- **Behavior Testing**: Focus on testing behavior rather than implementation details\n- **Fast Feedback**: Quick test execution with proper isolation\n- **Outside-In Development**: Start with acceptance tests and work inward\n\n## ğŸš€ Quick Start\n\n### Running Tests\n\n```bash\n# Run all tests\nflutter test\n\n# Run specific test types\nflutter test test/unit/\nflutter test test/widget/\nflutter test test/integration/\n\n# Run with coverage\nflutter test --coverage\n\n# Run integration tests\nflutter test integration_test/\n```\n\n### Test Coverage\n\n```bash\n# Generate coverage report\nflutter test --coverage\n\n# Generate HTML coverage report\ngenhtml coverage/lcov.info -o coverage/html\n\n# Open coverage report\nopen coverage/html/index.html\n```\n\n## ğŸ“‹ Testing Standards\n\n### Test Organization\n\n1. **Group Related Tests**: Use `group()` to organize related test cases\n2. **Descriptive Names**: Test names should clearly describe what is being tested\n3. **Setup/Teardown**: Use `setUp()` and `tearDown()` for test preparation and cleanup\n4. **Test Data Builders**: Use builder pattern for creating test data\n\n### Test Structure (AAA Pattern)\n\n```dart\ntest('should create family when valid data is provided', () async {\n  // ARRANGE\n  final usecase = CreateFamilyUsecase(mockRepository);\n  final params = CreateFamilyParams(name: 'Test Family');\n  \n  when(mockRepository.createFamily(name: 'Test Family'))\n      .thenAnswer((_) async => TestBuilders.success(\n        TestBuilders.family().withName('Test Family').build()\n      ).build());\n  \n  // ACT\n  final result = await usecase.call(params);\n  \n  // ASSERT\n  expect(result, isA<Ok<Family, Failure>>());\n  verify(mockRepository.createFamily(name: 'Test Family')).called(1);\n});\n```\n\n## ğŸ§ª Test Types\n\n### Unit Tests (`test/unit/`)\n\n- **Purpose**: Test individual classes/functions in isolation\n- **Scope**: Single class or function\n- **Dependencies**: Mocked\n- **Speed**: Very fast (< 10ms per test)\n- **Coverage Target**: 90%+\n\n**Example**: Testing a use case class\n\n```dart\nvoid main() {\n  group('CreateFamilyUsecase', () {\n    late CreateFamilyUsecase usecase;\n    late MockFamilyRepository mockRepository;\n    \n    setUp(() {\n      mockRepository = MockFamilyRepository();\n      usecase = CreateFamilyUsecase(mockRepository);\n    });\n    \n    test('should create family successfully', () async {\n      // Test implementation\n    });\n  });\n}\n```\n\n### Widget Tests (`test/widget/`)\n\n- **Purpose**: Test widget behavior and UI interactions\n- **Scope**: Single widget or widget tree\n- **Dependencies**: Mocked services, real UI\n- **Speed**: Fast (< 100ms per test)\n- **Coverage Target**: 80%+\n\n**Example**: Testing a page widget\n\n```dart\nvoid main() {\n  group('CreateFamilyPage', () {\n    testWidgets('should display form elements', (tester) async {\n      await tester.pumpWidget(\n        TestApp(child: CreateFamilyPage()),\n      );\n      \n      expect(find.text('Family Name'), findsOneWidget);\n      expect(find.byType(TextFormField), findsOneWidget);\n      expect(find.text('Create'), findsOneWidget);\n    });\n  });\n}\n```\n\n### Integration Tests (`test/integration/`)\n\n- **Purpose**: Test complete user flows end-to-end\n- **Scope**: Multiple widgets/pages, full app functionality\n- **Dependencies**: Real or test backend, real navigation\n- **Speed**: Slower (< 5s per test)\n- **Coverage Target**: 70%+\n\n**Example**: Testing user journey\n\n```dart\nvoid main() {\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n  \n  group('Family Creation Flow', () {\n    testWidgets('should create family end-to-end', (tester) async {\n      await app.main();\n      await tester.pumpAndSettle();\n      \n      // Navigate to family creation\n      await tester.tap(find.text('Create Family'));\n      await tester.pumpAndSettle();\n      \n      // Fill form and submit\n      await tester.enterText(find.byType(TextFormField), 'Test Family');\n      await tester.tap(find.text('Create'));\n      await tester.pumpAndSettle();\n      \n      // Verify success\n      expect(find.text('Family created successfully'), findsOneWidget);\n    });\n  });\n}\n```\n\n## ğŸ› ï¸ Testing Infrastructure\n\n### Test Builders\n\nUse builders for creating test data:\n\n```dart\n// Create a user for testing\nfinal user = TestBuilders.user()\n    .withEmail('test@example.com')\n    .withName('Test User')\n    .build();\n\n// Create a family for testing\nfinal family = TestBuilders.family()\n    .withName('Test Family')\n    .withOwner(user.id)\n    .build();\n```\n\n### Mock Factories\n\nUse factories for consistent mock configuration:\n\n```dart\n// Configure successful flow\nAuthServiceMockFactory.configureSuccessFlow(mockAuthService);\n\n// Configure error scenarios\nFamilyRepositoryMockFactory.configureCreationFailure(mockFamilyRepo);\n```\n\n### Test Environment\n\nBase classes provide common functionality:\n\n```dart\nclass MyWidgetTest extends WidgetTestBase {\n  @override\n  Future<void> configureMocks() async {\n    MockConfigurator.configureHappyPath();\n  }\n  \n  @override\n  Future<void> configureProviders() async {\n    providerOverrides.addAll([\n      authServiceProvider.overrideWithValue(mockAuthService),\n    ]);\n  }\n}\n```\n\n## ğŸ¨ Golden File Testing\n\nVisual regression testing with golden files:\n\n```dart\ntestWidgets('should match golden file', (tester) async {\n  await tester.pumpWidget(MyWidget());\n  \n  await expectLater(\n    find.byType(MyWidget),\n    matchesGoldenFile('my_widget.png'),\n  );\n});\n```\n\n### Golden File Organization\n\n- `goldens/` - Standard golden files\n- `goldens/accessibility/` - High contrast/accessibility variants\n- `goldens/loading/` - Loading state golden files\n- `goldens/errors/` - Error state golden files\n\n## â™¿ Accessibility Testing\n\nEvery widget test should include accessibility checks:\n\n```dart\ntestWidgets('should be accessible', (tester) async {\n  await tester.pumpWidget(MyWidget());\n  \n  // Run accessibility test suite\n  await AccessibilityTestHelper.runAccessibilityTestSuite(\n    tester,\n    requiredLabels: ['Submit', 'Cancel'],\n  );\n});\n```\n\n## ğŸ“Š Performance Testing\n\nMonitor performance during tests:\n\n```dart\ntestWidgets('should render quickly', (tester) async {\n  final stopwatch = Stopwatch()..start();\n  \n  await tester.pumpWidget(MyWidget());\n  \n  stopwatch.stop();\n  expect(\n    stopwatch.elapsedMilliseconds,\n    lessThan(100),\n    reason: 'Widget should render within 100ms',\n  );\n});\n```\n\n## ğŸ“ˆ Test Coverage\n\n### Coverage Targets\n\n- **Overall**: 85%+\n- **Unit Tests**: 90%+\n- **Widget Tests**: 80%+\n- **Integration Tests**: 70%+\n- **Core Utilities**: 95%+\n- **Domain Layer**: 90%+\n\n### Running Coverage Analysis\n\n```bash\n# Generate coverage\nflutter test --coverage\n\n# Validate coverage thresholds\ndart test/support/test_coverage_config.dart\n\n# Generate detailed report\ngenhtml coverage/lcov.info -o coverage/html\n```\n\n## ğŸ”„ Continuous Integration\n\n### Test Pipeline\n\n```yaml\n# .github/workflows/test.yml\nname: Test\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: subosito/flutter-action@v2\n      \n      # Unit tests\n      - run: flutter test test/unit/ --coverage\n      \n      # Widget tests\n      - run: flutter test test/widget/ --update-goldens\n      \n      # Integration tests\n      - run: flutter test integration_test/\n      \n      # Coverage validation\n      - run: dart test/support/test_coverage_config.dart\n```\n\n## ğŸ—ï¸ Test-Driven Development Workflow\n\n### TDD London School Process\n\n1. **Write Acceptance Test** (Integration level)\n   - Define the desired behavior from user's perspective\n   - Test should fail initially (RED)\n\n2. **Write Unit Tests** (Unit level)\n   - Work outside-in, defining component interfaces\n   - Mock dependencies, focus on behavior\n\n3. **Implement** (GREEN)\n   - Write minimal code to make tests pass\n   - Use mocks to define contracts between components\n\n4. **Refactor** (REFACTOR)\n   - Improve code structure without changing behavior\n   - Ensure all tests still pass\n\n5. **Repeat**\n   - Continue until acceptance test passes\n\n### Example TDD Cycle\n\n```dart\n// 1. RED - Write failing test\ntest('should create family when valid name provided', () async {\n  // This test will fail because CreateFamilyUsecase doesn't exist yet\n  final usecase = CreateFamilyUsecase(mockRepository);\n  final result = await usecase.call(CreateFamilyParams(name: 'Test'));\n  expect(result, isA<Ok<Family, Failure>>());\n});\n\n// 2. GREEN - Implement minimal code\nclass CreateFamilyUsecase {\n  Future<Result<Family, Failure>> call(CreateFamilyParams params) async {\n    // Minimal implementation to make test pass\n    return Result.ok(Family(id: '1', name: params.name));\n  }\n}\n\n// 3. REFACTOR - Improve implementation\nclass CreateFamilyUsecase {\n  final FamilyRepository repository;\n  \n  Future<Result<Family, Failure>> call(CreateFamilyParams params) async {\n    if (params.name.isEmpty) {\n      return Result.err(ValidationFailure('Name required'));\n    }\n    return repository.createFamily(name: params.name);\n  }\n}\n```\n\n## ğŸ› Debugging Tests\n\n### Common Issues\n\n1. **Test Timeouts**\n   ```dart\n   // Use pumpAndSettle with timeout\n   await tester.pumpAndSettle(Duration(seconds: 5));\n   ```\n\n2. **Provider Not Found**\n   ```dart\n   // Ensure provider is overridden in test\n   ProviderScope(\n     overrides: [myProvider.overrideWithValue(mockValue)],\n     child: MyWidget(),\n   )\n   ```\n\n3. **Golden File Mismatches**\n   ```bash\n   # Update golden files\n   flutter test --update-goldens\n   ```\n\n### Debugging Tools\n\n```dart\n// Print widget tree\ndebugDumpApp();\n\n// Print render tree\ndebugDumpRenderTree();\n\n// Take screenshots during test\nawait binding.takeScreenshot('debug_screenshot');\n```\n\n## ğŸ“š Best Practices Summary\n\n### DO\n\nâœ… **Use descriptive test names** that explain the behavior being tested\n\nâœ… **Follow AAA pattern** (Arrange, Act, Assert) in all tests\n\nâœ… **Mock all external dependencies** in unit tests\n\nâœ… **Test behavior, not implementation** details\n\nâœ… **Use test builders** for creating test data\n\nâœ… **Include accessibility tests** for all UI components\n\nâœ… **Verify error scenarios** alongside happy paths\n\nâœ… **Monitor test performance** and keep tests fast\n\nâœ… **Use golden files** for visual regression testing\n\nâœ… **Write tests first** (TDD approach)\n\n### DON'T\n\nâŒ **Don't test implementation details** (private methods, internal state)\n\nâŒ **Don't share state between tests** (use setUp/tearDown)\n\nâŒ **Don't use real services** in unit tests (use mocks)\n\nâŒ **Don't write overly complex tests** (split into smaller tests)\n\nâŒ **Don't ignore failing tests** (fix or remove them)\n\nâŒ **Don't skip edge cases** (test boundary conditions)\n\nâŒ **Don't forget cleanup** (dispose resources, reset mocks)\n\nâŒ **Don't hardcode test data** (use builders and factories)\n\n## ğŸ”— Additional Resources\n\n- [Flutter Testing Documentation](https://flutter.dev/docs/testing)\n- [Mockito Documentation](https://pub.dev/packages/mockito)\n- [Integration Testing](https://flutter.dev/docs/testing/integration-tests)\n- [Golden File Testing](https://flutter.dev/docs/testing/integration-tests#golden-file-testing)\n- [TDD London School](https://martinfowler.com/articles/mocksArentStubs.html)\n\n---\n\n**Remember**: Good tests are not just about coverage numbersâ€”they should provide confidence in your code, enable safe refactoring, and serve as documentation for how your system should behave.\n"